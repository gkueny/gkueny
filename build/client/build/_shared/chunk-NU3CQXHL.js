import {
  require_xml_doc
} from "/build/_shared/chunk-HADVB6BA.js";
import {
  require_xojo
} from "/build/_shared/chunk-GIHWFRRG.js";
import {
  require_xquery
} from "/build/_shared/chunk-AC74EC6G.js";
import {
  require_yang
} from "/build/_shared/chunk-4ZUNKDEO.js";
import {
  require_zig
} from "/build/_shared/chunk-CFFLQJDP.js";
import {
  require_core
} from "/build/_shared/chunk-VNULAXSC.js";
import {
  require_verilog
} from "/build/_shared/chunk-EUEELJVY.js";
import {
  require_vhdl
} from "/build/_shared/chunk-DU7UED4T.js";
import {
  require_vim
} from "/build/_shared/chunk-H5PHWBLA.js";
import {
  require_visual_basic
} from "/build/_shared/chunk-ZDT6JT3L.js";
import {
  require_warpscript
} from "/build/_shared/chunk-YZEE5OLE.js";
import {
  require_wasm
} from "/build/_shared/chunk-XFBOUGXC.js";
import {
  require_wiki
} from "/build/_shared/chunk-WDBEIBTN.js";
import {
  require_xeora
} from "/build/_shared/chunk-7RAWVCLE.js";
import {
  require_toml
} from "/build/_shared/chunk-OQANNPHU.js";
import {
  require_tsx
} from "/build/_shared/chunk-JBZ5C6VA.js";
import {
  require_tt2
} from "/build/_shared/chunk-FUNN3PI2.js";
import {
  require_twig
} from "/build/_shared/chunk-ZBC4FT7Z.js";
import {
  require_typoscript
} from "/build/_shared/chunk-4Q5XP2WL.js";
import {
  require_unrealscript
} from "/build/_shared/chunk-3QFVLDNV.js";
import {
  require_vala
} from "/build/_shared/chunk-OBHWRQBX.js";
import {
  require_velocity
} from "/build/_shared/chunk-IE3GQDSE.js";
import {
  require_t4_cs
} from "/build/_shared/chunk-YMUY6AMC.js";
import {
  require_t4_vb
} from "/build/_shared/chunk-NCQOTRW7.js";
import {
  require_t4_templating
} from "/build/_shared/chunk-WFXZFCEH.js";
import {
  require_vbnet
} from "/build/_shared/chunk-MK4L3SRG.js";
import {
  require_tap
} from "/build/_shared/chunk-EDZGMLAA.js";
import {
  require_yaml
} from "/build/_shared/chunk-MFRFJWK5.js";
import {
  require_tcl
} from "/build/_shared/chunk-ZC4C5SXX.js";
import {
  require_textile
} from "/build/_shared/chunk-2A7ZCWYX.js";
import {
  require_soy
} from "/build/_shared/chunk-KQQH33JU.js";
import {
  require_sparql
} from "/build/_shared/chunk-UNBM6ITG.js";
import {
  require_turtle
} from "/build/_shared/chunk-GBHPM4GS.js";
import {
  require_splunk_spl
} from "/build/_shared/chunk-IPQXJRNB.js";
import {
  require_sqf
} from "/build/_shared/chunk-RRBQNHSO.js";
import {
  require_stan
} from "/build/_shared/chunk-3DKUZ372.js";
import {
  require_stylus
} from "/build/_shared/chunk-VI5JI3PL.js";
import {
  require_swift
} from "/build/_shared/chunk-T5JNBO7X.js";
import {
  require_scss
} from "/build/_shared/chunk-HZ3JBVQI.js";
import {
  require_shell_session
} from "/build/_shared/chunk-CFYBOGAT.js";
import {
  require_smali
} from "/build/_shared/chunk-3DGWQHGC.js";
import {
  require_smalltalk
} from "/build/_shared/chunk-GK7EVV2D.js";
import {
  require_smarty
} from "/build/_shared/chunk-ZR4EN5JN.js";
import {
  require_sml
} from "/build/_shared/chunk-3XSYU645.js";
import {
  require_solidity
} from "/build/_shared/chunk-LV6H5KOX.js";
import {
  require_solution_file
} from "/build/_shared/chunk-IEIJTQ7D.js";
import {
  require_rest
} from "/build/_shared/chunk-ZAZMA25W.js";
import {
  require_rip
} from "/build/_shared/chunk-CVCXVGPE.js";
import {
  require_roboconf
} from "/build/_shared/chunk-MW5TI7ZT.js";
import {
  require_robotframework
} from "/build/_shared/chunk-PQXZPWYO.js";
import {
  require_rust
} from "/build/_shared/chunk-4L7LSA3N.js";
import {
  require_sas
} from "/build/_shared/chunk-P4FNIK2U.js";
import {
  require_sass
} from "/build/_shared/chunk-53F5G7V3.js";
import {
  require_scala
} from "/build/_shared/chunk-3Q2HQ4WP.js";
import {
  require_q
} from "/build/_shared/chunk-W2XAK7MD.js";
import {
  require_qml
} from "/build/_shared/chunk-VJZNADXD.js";
import {
  require_qore
} from "/build/_shared/chunk-4TAWFGYV.js";
import {
  require_r
} from "/build/_shared/chunk-ZBUAODGR.js";
import {
  require_racket
} from "/build/_shared/chunk-GGGBZHRO.js";
import {
  require_reason
} from "/build/_shared/chunk-6CC7A4AO.js";
import {
  require_regex
} from "/build/_shared/chunk-E25QJWKN.js";
import {
  require_renpy
} from "/build/_shared/chunk-5SQ7LMWO.js";
import {
  require_properties
} from "/build/_shared/chunk-AQALRHD2.js";
import {
  require_protobuf
} from "/build/_shared/chunk-5GXFDHSC.js";
import {
  require_pug
} from "/build/_shared/chunk-DRHDO5XZ.js";
import {
  require_puppet
} from "/build/_shared/chunk-B4CVDURG.js";
import {
  require_pure
} from "/build/_shared/chunk-IMX5VZL3.js";
import {
  require_purebasic
} from "/build/_shared/chunk-MYN2NKV7.js";
import {
  require_purescript
} from "/build/_shared/chunk-MLE34BQP.js";
import {
  require_python
} from "/build/_shared/chunk-LA6LFCP7.js";
import {
  require_php_extras
} from "/build/_shared/chunk-ZHQBY7XX.js";
import {
  require_phpdoc
} from "/build/_shared/chunk-GPUCKBX3.js";
import {
  require_plsql
} from "/build/_shared/chunk-5YRIY7CJ.js";
import {
  require_sql
} from "/build/_shared/chunk-NJ3OYC6D.js";
import {
  require_powerquery
} from "/build/_shared/chunk-7WEF4YUQ.js";
import {
  require_powershell
} from "/build/_shared/chunk-OFVWTKXG.js";
import {
  require_processing
} from "/build/_shared/chunk-M4I557PZ.js";
import {
  require_prolog
} from "/build/_shared/chunk-EHOS5MZD.js";
import {
  require_oz
} from "/build/_shared/chunk-OXUKV5B2.js";
import {
  require_parigp
} from "/build/_shared/chunk-EYI2IED5.js";
import {
  require_parser
} from "/build/_shared/chunk-TYRRL3TO.js";
import {
  require_pascal
} from "/build/_shared/chunk-WAEDUCFO.js";
import {
  require_pascaligo
} from "/build/_shared/chunk-YDQLUEII.js";
import {
  require_pcaxis
} from "/build/_shared/chunk-SXOPXZQQ.js";
import {
  require_peoplecode
} from "/build/_shared/chunk-OJRPHNWZ.js";
import {
  require_perl
} from "/build/_shared/chunk-DI27MEDC.js";
import {
  require_neon
} from "/build/_shared/chunk-CT5NZD3T.js";
import {
  require_nginx
} from "/build/_shared/chunk-URZQCQ34.js";
import {
  require_nim
} from "/build/_shared/chunk-6AQI35YW.js";
import {
  require_nix
} from "/build/_shared/chunk-JQ75Y4GI.js";
import {
  require_nsis
} from "/build/_shared/chunk-KQWXV47Z.js";
import {
  require_objectivec
} from "/build/_shared/chunk-DPKHX7SF.js";
import {
  require_ocaml
} from "/build/_shared/chunk-RVNSNH5L.js";
import {
  require_opencl
} from "/build/_shared/chunk-OV2XMZRI.js";
import {
  require_mongodb
} from "/build/_shared/chunk-6F323L2C.js";
import {
  require_monkey
} from "/build/_shared/chunk-IEEQLSXW.js";
import {
  require_moonscript
} from "/build/_shared/chunk-7AP5CNLC.js";
import {
  require_n1ql
} from "/build/_shared/chunk-5R4JCLLQ.js";
import {
  require_n4js
} from "/build/_shared/chunk-KVQYJIQB.js";
import {
  require_nand2tetris_hdl
} from "/build/_shared/chunk-AFMIQVAY.js";
import {
  require_naniscript
} from "/build/_shared/chunk-AUPUFUCO.js";
import {
  require_nasm
} from "/build/_shared/chunk-4PPRLQRI.js";
import {
  require_llvm
} from "/build/_shared/chunk-33H6TNBQ.js";
import {
  require_lolcode
} from "/build/_shared/chunk-CPUMAAOO.js";
import {
  require_makefile
} from "/build/_shared/chunk-AMDOJHD2.js";
import {
  require_markdown
} from "/build/_shared/chunk-2LDHME44.js";
import {
  require_matlab
} from "/build/_shared/chunk-GRYPM3ON.js";
import {
  require_mel
} from "/build/_shared/chunk-6JQ64D2K.js";
import {
  require_mizar
} from "/build/_shared/chunk-2XK5NR5R.js";
import {
  require_latte
} from "/build/_shared/chunk-WGTNS4MC.js";
import {
  require_php
} from "/build/_shared/chunk-2NWADT2B.js";
import {
  require_less
} from "/build/_shared/chunk-VE44DKCV.js";
import {
  require_lilypond
} from "/build/_shared/chunk-QBHHHYKS.js";
import {
  require_scheme
} from "/build/_shared/chunk-P2RNTPBC.js";
import {
  require_liquid
} from "/build/_shared/chunk-XU67OLTE.js";
import {
  require_lisp
} from "/build/_shared/chunk-HFTMIHWZ.js";
import {
  require_livescript
} from "/build/_shared/chunk-GMSIPAVI.js";
import {
  require_json5
} from "/build/_shared/chunk-US4BWZPS.js";
import {
  require_jsonp
} from "/build/_shared/chunk-XKFKXBR7.js";
import {
  require_jsstacktrace
} from "/build/_shared/chunk-A2QPBQV5.js";
import {
  require_jsx
} from "/build/_shared/chunk-TZR6N75R.js";
import {
  require_julia
} from "/build/_shared/chunk-COWVY5H7.js";
import {
  require_keyman
} from "/build/_shared/chunk-NHLYNXOJ.js";
import {
  require_kotlin
} from "/build/_shared/chunk-P3WPBOYJ.js";
import {
  require_latex
} from "/build/_shared/chunk-XRDTXIPT.js";
import {
  require_javastacktrace
} from "/build/_shared/chunk-BX6PPUAL.js";
import {
  require_jolie
} from "/build/_shared/chunk-4ALQXXIB.js";
import {
  require_jq
} from "/build/_shared/chunk-TA2BY7WU.js";
import {
  require_js_extras
} from "/build/_shared/chunk-YY7U5KU3.js";
import {
  require_js_templates
} from "/build/_shared/chunk-ZUFYLTK6.js";
import {
  require_jsdoc
} from "/build/_shared/chunk-2LOTW4OY.js";
import {
  require_typescript
} from "/build/_shared/chunk-KJNYAVRP.js";
import {
  require_json
} from "/build/_shared/chunk-OQQGOZHT.js";
import {
  require_inform7
} from "/build/_shared/chunk-XP5KUXOX.js";
import {
  require_ini
} from "/build/_shared/chunk-4MWO3K6X.js";
import {
  require_io
} from "/build/_shared/chunk-IRJEYEPP.js";
import {
  require_j
} from "/build/_shared/chunk-WR2HVL5V.js";
import {
  require_javadoc
} from "/build/_shared/chunk-4GYSWVMH.js";
import {
  require_java
} from "/build/_shared/chunk-ALLEOL22.js";
import {
  require_javadoclike
} from "/build/_shared/chunk-MN5IJP33.js";
import {
  require_hlsl
} from "/build/_shared/chunk-4WME7HQE.js";
import {
  require_hpkp
} from "/build/_shared/chunk-2VV6CJML.js";
import {
  require_hsts
} from "/build/_shared/chunk-XW3RWQN2.js";
import {
  require_http
} from "/build/_shared/chunk-U74OGP5N.js";
import {
  require_ichigojam
} from "/build/_shared/chunk-ICYMTONU.js";
import {
  require_icon
} from "/build/_shared/chunk-AYJMM3S3.js";
import {
  require_iecst
} from "/build/_shared/chunk-FKSSS4MO.js";
import {
  require_ignore
} from "/build/_shared/chunk-TZ5XYIWS.js";
import {
  require_go
} from "/build/_shared/chunk-XTLPZ6CG.js";
import {
  require_graphql
} from "/build/_shared/chunk-H3PFCR54.js";
import {
  require_groovy
} from "/build/_shared/chunk-KH727REY.js";
import {
  require_haml
} from "/build/_shared/chunk-247VSPNP.js";
import {
  require_handlebars
} from "/build/_shared/chunk-RRNZ7UKW.js";
import {
  require_haskell
} from "/build/_shared/chunk-L4E26EQA.js";
import {
  require_haxe
} from "/build/_shared/chunk-FOPIVYW5.js";
import {
  require_hcl
} from "/build/_shared/chunk-T3K26VIJ.js";
import {
  require_ftl
} from "/build/_shared/chunk-CYSEVSHX.js";
import {
  require_gcode
} from "/build/_shared/chunk-EELHYMMT.js";
import {
  require_gdscript
} from "/build/_shared/chunk-5L634YIQ.js";
import {
  require_gedcom
} from "/build/_shared/chunk-KKFIE2D7.js";
import {
  require_gherkin
} from "/build/_shared/chunk-MF7R4RSW.js";
import {
  require_git
} from "/build/_shared/chunk-SI2KVB3J.js";
import {
  require_glsl
} from "/build/_shared/chunk-2TDHUCL4.js";
import {
  require_gml
} from "/build/_shared/chunk-Y2572ADT.js";
import {
  require_etlua
} from "/build/_shared/chunk-P4YXX546.js";
import {
  require_lua
} from "/build/_shared/chunk-IWFLW7YN.js";
import {
  require_excel_formula
} from "/build/_shared/chunk-LUXKD5AO.js";
import {
  require_factor
} from "/build/_shared/chunk-MB3MKVZ7.js";
import {
  require_firestore_security_rules
} from "/build/_shared/chunk-7VJS3CLE.js";
import {
  require_flow
} from "/build/_shared/chunk-2PNHHKRK.js";
import {
  require_fortran
} from "/build/_shared/chunk-VGZL5M3X.js";
import {
  require_fsharp
} from "/build/_shared/chunk-DMG6LL3Z.js";
import {
  require_ebnf
} from "/build/_shared/chunk-BXUIVAW3.js";
import {
  require_editorconfig
} from "/build/_shared/chunk-CGV7YIWU.js";
import {
  require_eiffel
} from "/build/_shared/chunk-7WMZL5XO.js";
import {
  require_ejs
} from "/build/_shared/chunk-YHQLDL2P.js";
import {
  require_elixir
} from "/build/_shared/chunk-ANMDD574.js";
import {
  require_elm
} from "/build/_shared/chunk-ILWQWJVC.js";
import {
  require_erb
} from "/build/_shared/chunk-3S4UBH4H.js";
import {
  require_erlang
} from "/build/_shared/chunk-UQJCYFIF.js";
import {
  require_dart
} from "/build/_shared/chunk-BSGTXST4.js";
import {
  require_dax
} from "/build/_shared/chunk-M4AARJ3N.js";
import {
  require_dhall
} from "/build/_shared/chunk-VILZB5MC.js";
import {
  require_diff
} from "/build/_shared/chunk-3LA7JZV2.js";
import {
  require_django
} from "/build/_shared/chunk-UQ6V4VVR.js";
import {
  require_markup_templating
} from "/build/_shared/chunk-FDPXNRAA.js";
import {
  require_dns_zone_file
} from "/build/_shared/chunk-WZTFH5RA.js";
import {
  require_docker
} from "/build/_shared/chunk-3BEPGWP7.js";
import {
  require_concurnas
} from "/build/_shared/chunk-PAO6433U.js";
import {
  require_crystal
} from "/build/_shared/chunk-O2VQGJL3.js";
import {
  require_ruby
} from "/build/_shared/chunk-A6EO4D5P.js";
import {
  require_csp
} from "/build/_shared/chunk-YQ3A4NOX.js";
import {
  require_css_extras
} from "/build/_shared/chunk-QQCHBWQF.js";
import {
  require_cypher
} from "/build/_shared/chunk-EP343ENR.js";
import {
  require_d
} from "/build/_shared/chunk-7ABEP5NT.js";
import {
  require_brightscript
} from "/build/_shared/chunk-X2OT22MN.js";
import {
  require_bro
} from "/build/_shared/chunk-EQCCCOH2.js";
import {
  require_bsl
} from "/build/_shared/chunk-IV4FQR55.js";
import {
  require_cil
} from "/build/_shared/chunk-KAWSKJJX.js";
import {
  require_clojure
} from "/build/_shared/chunk-M3MHL5OQ.js";
import {
  require_cmake
} from "/build/_shared/chunk-NAZ6YMG2.js";
import {
  require_coffeescript
} from "/build/_shared/chunk-TQ4NDH5E.js";
import {
  require_bash
} from "/build/_shared/chunk-4TBREZLG.js";
import {
  require_basic
} from "/build/_shared/chunk-4LAZXXWJ.js";
import {
  require_batch
} from "/build/_shared/chunk-TL277NQ6.js";
import {
  require_bbcode
} from "/build/_shared/chunk-QGSUX4KV.js";
import {
  require_birb
} from "/build/_shared/chunk-AR55V6KM.js";
import {
  require_bison
} from "/build/_shared/chunk-3HLYT5SO.js";
import {
  require_bnf
} from "/build/_shared/chunk-3PMUXNGD.js";
import {
  require_brainfuck
} from "/build/_shared/chunk-NFHGHGND.js";
import {
  require_arduino
} from "/build/_shared/chunk-3YP5KUOW.js";
import {
  require_arff
} from "/build/_shared/chunk-6EGY7FHK.js";
import {
  require_asciidoc
} from "/build/_shared/chunk-LGCAQVJU.js";
import {
  require_asm6502
} from "/build/_shared/chunk-XMXVXT3K.js";
import {
  require_aspnet
} from "/build/_shared/chunk-UR5EBYX3.js";
import {
  require_csharp
} from "/build/_shared/chunk-6ASK4ZVT.js";
import {
  require_autohotkey
} from "/build/_shared/chunk-B7Q2K2LU.js";
import {
  require_autoit
} from "/build/_shared/chunk-KMPFE5JU.js";
import {
  require_al
} from "/build/_shared/chunk-7FRNO466.js";
import {
  require_antlr4
} from "/build/_shared/chunk-H2QANQ3O.js";
import {
  require_apacheconf
} from "/build/_shared/chunk-T37FIGJR.js";
import {
  require_apl
} from "/build/_shared/chunk-5PLTTTNZ.js";
import {
  require_applescript
} from "/build/_shared/chunk-QQ62PHGQ.js";
import {
  require_aql
} from "/build/_shared/chunk-WUJB4E7X.js";
import {
  require_cpp
} from "/build/_shared/chunk-IVJLF4FW.js";
import {
  require_c
} from "/build/_shared/chunk-SUOMF4KV.js";
import {
  require_abap
} from "/build/_shared/chunk-JZ2HI2NJ.js";
import {
  require_abnf
} from "/build/_shared/chunk-UURSWLAX.js";
import {
  require_actionscript
} from "/build/_shared/chunk-CYJP4XMH.js";
import {
  require_ada
} from "/build/_shared/chunk-Z45QRYZG.js";
import {
  require_agda
} from "/build/_shared/chunk-JK7SUEIS.js";
import {
  __commonJS
} from "/build/_shared/chunk-PNG5AS42.js";

// node_modules/refractor/lang/apex.js
var require_apex = __commonJS({
  "node_modules/refractor/lang/apex.js"(exports, module) {
    "use strict";
    var refractorSql = require_sql();
    module.exports = apex;
    apex.displayName = "apex";
    apex.aliases = [];
    function apex(Prism) {
      Prism.register(refractorSql);
      (function(Prism2) {
        var keywords = /\b(?:abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|get(?=\s*[{};])|(?:after|before)(?=\s+[a-z])|(?:inherited|with|without)\s+sharing)\b/i;
        var className = /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(
          /<keyword>/g,
          function() {
            return keywords.source;
          }
        );
        function insertClassName(pattern) {
          return RegExp(
            pattern.replace(/<CLASS-NAME>/g, function() {
              return className;
            }),
            "i"
          );
        }
        var classNameInside = {
          keyword: keywords,
          punctuation: /[()\[\]{};,:.<>]/
        };
        Prism2.languages.apex = {
          comment: Prism2.languages.clike.comment,
          string: Prism2.languages.clike.string,
          sql: {
            pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
            lookbehind: true,
            greedy: true,
            alias: "language-sql",
            inside: Prism2.languages.sql
          },
          annotation: {
            pattern: /@\w+\b/,
            alias: "punctuation"
          },
          "class-name": [
            {
              pattern: insertClassName(
                /(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/.source
              ),
              lookbehind: true,
              inside: classNameInside
            },
            {
              // cast
              pattern: insertClassName(
                /(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source
              ),
              lookbehind: true,
              inside: classNameInside
            },
            {
              // variable/parameter declaration and return types
              pattern: insertClassName(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source),
              inside: classNameInside
            }
          ],
          trigger: {
            pattern: /(\btrigger\s+)\w+\b/i,
            lookbehind: true,
            alias: "class-name"
          },
          keyword: keywords,
          function: /\b[a-z_]\w*(?=\s*\()/i,
          boolean: /\b(?:false|true)\b/i,
          number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
          operator: /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
          punctuation: /[()\[\]{};,.]/
        };
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/avisynth.js
var require_avisynth = __commonJS({
  "node_modules/refractor/lang/avisynth.js"(exports, module) {
    "use strict";
    module.exports = avisynth;
    avisynth.displayName = "avisynth";
    avisynth.aliases = ["avs"];
    function avisynth(Prism) {
      ;
      (function(Prism2) {
        function replace(pattern, replacements) {
          return pattern.replace(/<<(\d+)>>/g, function(m, index) {
            return replacements[+index];
          });
        }
        function re(pattern, replacements, flags) {
          return RegExp(replace(pattern, replacements), flags || "");
        }
        var types = /clip|int|float|string|bool|val/.source;
        var internals = [
          // bools
          /is(?:bool|clip|float|int|string)|defined|(?:var|(?:internal)?function)?exists?/.source,
          // control
          /apply|assert|default|eval|import|select|nop|undefined/.source,
          // global
          /set(?:memorymax|cachemode|maxcpu|workingdir|planarlegacyalignment)|opt_(?:allowfloataudio|usewaveextensible|dwchannelmask|avipadscanlines|vdubplanarhack|enable_(?:v210|y3_10_10|y3_10_16|b64a|planartopackedrgb))/.source,
          // conv
          /hex(?:value)?|value/.source,
          // numeric
          /max|min|muldiv|floor|ceil|round|fmod|pi|exp|log(?:10)?|pow|sqrt|abs|sign|frac|rand|spline|continued(?:numerator|denominator)?/.source,
          // trig
          /a?sinh?|a?cosh?|a?tan[2h]?/.source,
          // bit
          /(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/.source,
          // runtime
          /average(?:luma|chroma[uv]|[bgr])|(?:luma|chroma[uv]|rgb|[rgb]|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/.source,
          // script
          /script(?:name(?:utf8)?|file(?:utf8)?|dir(?:utf8)?)|setlogparams|logmsg|getprocessinfo/.source,
          // string
          /[lu]case|str(?:toutf8|fromutf8|len|cmpi?)|(?:rev|left|right|mid|find|replace|fill)str|format|trim(?:left|right|all)|chr|ord|time/.source,
          // version
          /version(?:number|string)|isversionorgreater/.source,
          // helper
          /buildpixeltype|colorspacenametopixeltype/.source,
          // avsplus
          /setfiltermtmode|prefetch|addautoloaddir|on(?:cpu|cuda)/.source
        ].join("|");
        var properties = [
          // content
          /has(?:audio|video)/.source,
          // resolution
          /width|height/.source,
          // framerate
          /frame(?:count|rate)|framerate(?:numerator|denominator)/.source,
          // interlacing
          /is(?:field|frame)based|getparity/.source,
          // color format
          /pixeltype|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:y2|va?))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|hasalpha|componentsize|numcomponents|bitspercomponent/.source,
          // audio
          /audio(?:rate|duration|length(?:[fs]|lo|hi)?|channels|bits)|isaudio(?:float|int)/.source
        ].join("|");
        var filters = [
          // source
          /avi(?:file)?source|opendmlsource|directshowsource|image(?:reader|source|sourceanim)|segmented(?:avisource|directshowsource)|wavsource/.source,
          // color
          /coloryuv|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:444|422|420|411)|YUY2)|convertbacktoyuy2|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:luma|chroma)|rgbadjust|show(?:red|green|blue|alpha)|swapuv|tweak|[uv]toy8?|ytouv/.source,
          // overlay
          /(?:colorkey|reset)mask|mask(?:hs)?|layer|merge|overlay|subtract/.source,
          // geometry
          /addborders|crop(?:bottom)?|flip(?:horizontal|vertical)|letterbox|(?:horizontal|vertical)?reduceby2|(?:bicubic|bilinear|blackman|gauss|lanczos|lanczos4|point|sinc|spline(?:16|36|64))resize|skewrows|turn(?:left|right|180)/.source,
          // pixel
          /blur|sharpen|generalconvolution|(?:spatial|temporal)soften|fixbrokenchromaupsampling/.source,
          // timeline
          /trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|out|io)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/.source,
          // interlace
          /assume(?:frame|field)based|assume[bt]ff|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|rows|fields)|swapfields|weave(?:columns|rows)?/.source,
          // audio
          /amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|supereq|ssrc|timestretch/.source,
          // conditional
          /conditional(?:filter|select|reader)|frameevaluate|scriptclip|writefile(?:if|start|end)?|animate|applyrange|tcp(?:server|source)/.source,
          // export
          /imagewriter/.source,
          // debug
          /subtitle|blankclip|blackness|colorbars(?:hd)?|compare|dumpfiltergraph|setgraphanalysis|echo|histogram|info|messageclip|preroll|showfiveversions|show(?:framenumber|smpte|time)|stack(?:horizontal|vertical)|tone|version/.source
        ].join("|");
        var allinternals = [internals, properties, filters].join("|");
        Prism2.languages.avisynth = {
          comment: [
            {
              // Matches [* *] nestable block comments, but only supports 1 level of nested comments
              // /\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|<self>)*\*\]/
              pattern: /(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
              lookbehind: true,
              greedy: true
            },
            {
              // Matches /* */ block comments
              pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
              lookbehind: true,
              greedy: true
            },
            {
              // Matches # comments
              pattern: /(^|[^\\$])#.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          // Handle before strings because optional arguments are surrounded by double quotes
          argument: {
            pattern: re(/\b(?:<<0>>)\s+("?)\w+\1/.source, [types], "i"),
            inside: {
              keyword: /^\w+/
            }
          },
          // Optional argument assignment
          "argument-label": {
            pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
            lookbehind: true,
            inside: {
              "argument-name": {
                pattern: /^\w+/,
                alias: "punctuation"
              },
              punctuation: /=$/
            }
          },
          string: [
            {
              // triple double-quoted
              pattern: /"""[\s\S]*?"""/,
              greedy: true
            },
            {
              // single double-quoted
              pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
              greedy: true,
              inside: {
                constant: {
                  // These *are* case-sensitive!
                  pattern: /\b(?:DEFAULT_MT_MODE|(?:SCRIPT|MAINSCRIPT|PROGRAM)DIR|(?:USER|MACHINE)_(?:PLUS|CLASSIC)_PLUGINS)\b/
                }
              }
            }
          ],
          // The special "last" variable that takes the value of the last implicitly returned clip
          variable: /\b(?:last)\b/i,
          boolean: /\b(?:true|false|yes|no)\b/i,
          keyword: /\b(?:function|global|return|try|catch|if|else|while|for|__END__)\b/i,
          constant: /\bMT_(?:NICE_FILTER|MULTI_INSTANCE|SERIALIZED|SPECIAL_MT)\b/,
          // AviSynth's internal functions, filters, and properties
          "builtin-function": {
            pattern: re(/\b(?:<<0>>)\b/.source, [allinternals], "i"),
            alias: "function"
          },
          "type-cast": {
            pattern: re(/\b(?:<<0>>)(?=\s*\()/.source, [types], "i"),
            alias: "keyword"
          },
          // External/user-defined filters
          function: {
            pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
            lookbehind: true
          },
          // Matches a \ as the first or last character on a line
          "line-continuation": {
            pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
            lookbehind: true,
            alias: "punctuation"
          },
          number: /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
          operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
          punctuation: /[{}\[\]();,.]/
        };
        Prism2.languages.avs = Prism2.languages.avisynth;
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/avro-idl.js
var require_avro_idl = __commonJS({
  "node_modules/refractor/lang/avro-idl.js"(exports, module) {
    "use strict";
    module.exports = avroIdl;
    avroIdl.displayName = "avroIdl";
    avroIdl.aliases = [];
    function avroIdl(Prism) {
      Prism.languages["avro-idl"] = {
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
          greedy: true
        },
        string: [
          {
            pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\])'(?:[^\r\n'\\]|\\(?:[\s\S]|\d{1,3}))'/,
            lookbehind: true,
            greedy: true
          }
        ],
        annotation: {
          pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
          greedy: true,
          alias: "function"
        },
        "function-identifier": {
          pattern: /`[^\r\n`]+`(?=\s*\()/,
          greedy: true,
          alias: "function"
        },
        identifier: {
          pattern: /`[^\r\n`]+`/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
          lookbehind: true,
          greedy: true
        },
        keyword: /\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: [
          {
            pattern: /(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
            lookbehind: true
          },
          /-?\b(?:NaN|Infinity)\b/
        ],
        operator: /=/,
        punctuation: /[()\[\]{}<>.:,;-]/
      };
      Prism.languages.avdl = Prism.languages["avro-idl"];
    }
  }
});

// node_modules/refractor/lang/bicep.js
var require_bicep = __commonJS({
  "node_modules/refractor/lang/bicep.js"(exports, module) {
    "use strict";
    module.exports = bicep;
    bicep.displayName = "bicep";
    bicep.aliases = [];
    function bicep(Prism) {
      Prism.languages.bicep = {
        comment: [
          {
            // multiline comments eg /* ASDF */
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            // singleline comments eg // ASDF
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        property: [
          {
            pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i,
            lookbehind: true
          },
          {
            pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
            lookbehind: true,
            greedy: true
          }
        ],
        string: [
          {
            pattern: /'''[^'][\s\S]*?'''/,
            greedy: true
          },
          {
            pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
            lookbehind: true,
            greedy: true
          }
        ],
        "interpolated-string": {
          pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
          lookbehind: true,
          greedy: true,
          inside: {
            interpolation: {
              pattern: /\$\{[^{}\r\n]*\}/,
              inside: {
                expression: {
                  pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                  lookbehind: true
                },
                punctuation: /^\$\{|\}$/
              }
            },
            string: /[\s\S]+/
          }
        },
        datatype: {
          pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
          lookbehind: true,
          alias: "class-name"
        },
        boolean: /\b(?:true|false)\b/,
        // https://github.com/Azure/bicep/blob/114a3251b4e6e30082a58729f19a8cc4e374ffa6/src/textmate/bicep.tmlanguage#L184
        keyword: /\b(?:targetScope|resource|module|param|var|output|for|in|if|existing|null)\b/,
        decorator: /@\w+\b/,
        function: /\b[a-z_]\w*(?=[ \t]*\()/i,
        number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
        operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
        punctuation: /[{}[\];(),.:]/
      };
      Prism.languages.bicep["interpolated-string"].inside["interpolation"].inside["expression"].inside = Prism.languages.bicep;
    }
  }
});

// node_modules/refractor/lang/cfscript.js
var require_cfscript = __commonJS({
  "node_modules/refractor/lang/cfscript.js"(exports, module) {
    "use strict";
    module.exports = cfscript;
    cfscript.displayName = "cfscript";
    cfscript.aliases = [];
    function cfscript(Prism) {
      Prism.languages.cfscript = Prism.languages.extend("clike", {
        comment: [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            inside: {
              annotation: {
                pattern: /(?:^|[^.])@[\w\.]+/,
                alias: "punctuation"
              }
            }
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        keyword: /\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
        operator: [
          /\+\+|--|&&|\|\||::|=>|[!=]==|<=?|>=?|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|[?:]/,
          /\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/
        ],
        scope: {
          pattern: /\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
          alias: "global"
        },
        type: {
          pattern: /\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
          alias: "builtin"
        }
      });
      Prism.languages.insertBefore("cfscript", "keyword", {
        // This must be declared before keyword because we use "function" inside the lookahead
        "function-variable": {
          pattern: /[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: "function"
        }
      });
      delete Prism.languages.cfscript["class-name"];
      Prism.languages.cfc = Prism.languages["cfscript"];
    }
  }
});

// node_modules/refractor/lang/chaiscript.js
var require_chaiscript = __commonJS({
  "node_modules/refractor/lang/chaiscript.js"(exports, module) {
    "use strict";
    var refractorCpp = require_cpp();
    module.exports = chaiscript;
    chaiscript.displayName = "chaiscript";
    chaiscript.aliases = [];
    function chaiscript(Prism) {
      Prism.register(refractorCpp);
      Prism.languages.chaiscript = Prism.languages.extend("clike", {
        string: {
          pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
          lookbehind: true,
          greedy: true
        },
        "class-name": [
          {
            // e.g. class Rectangle { ... }
            pattern: /(\bclass\s+)\w+/,
            lookbehind: true
          },
          {
            // e.g. attr Rectangle::height, def Rectangle::area() { ... }
            pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/,
            lookbehind: true
          }
        ],
        keyword: /\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
        number: [Prism.languages.cpp.number, /\b(?:Infinity|NaN)\b/],
        operator: />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
      });
      Prism.languages.insertBefore("chaiscript", "operator", {
        "parameter-type": {
          // e.g. def foo(int x, Vector y) {...}
          pattern: /([,(]\s*)\w+(?=\s+\w)/,
          lookbehind: true,
          alias: "class-name"
        }
      });
      Prism.languages.insertBefore("chaiscript", "string", {
        "string-interpolation": {
          pattern: /(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
          lookbehind: true,
          greedy: true,
          inside: {
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
              lookbehind: true,
              inside: {
                "interpolation-expression": {
                  pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                  lookbehind: true,
                  inside: Prism.languages.chaiscript
                },
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                }
              }
            },
            string: /[\s\S]+/
          }
        }
      });
    }
  }
});

// node_modules/refractor/lang/cobol.js
var require_cobol = __commonJS({
  "node_modules/refractor/lang/cobol.js"(exports, module) {
    "use strict";
    module.exports = cobol;
    cobol.displayName = "cobol";
    cobol.aliases = [];
    function cobol(Prism) {
      Prism.languages.cobol = {
        comment: {
          pattern: /\*>.*|(^[ \t]*)\*.*/m,
          lookbehind: true,
          greedy: true
        },
        string: {
          pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
          greedy: true
        },
        level: {
          pattern: /(^[ \t]*)\d+\b/m,
          lookbehind: true,
          greedy: true,
          alias: "number"
        },
        "class-name": {
          // https://github.com/antlr/grammars-v4/blob/42edd5b687d183b5fa679e858a82297bd27141e7/cobol85/Cobol85.g4#L1015
          pattern: /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
          lookbehind: true,
          inside: {
            number: {
              pattern: /(\()\d+/,
              lookbehind: true
            },
            punctuation: /[()]/
          }
        },
        keyword: {
          pattern: /(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOUNDS|BOTTOM|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COLLATING|COL|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOP|ERASE|ERROR|EOL|EOS|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTIONNAME|FUNCTION-POINTER|GENERATE|GOBACK|GIVING|GLOBAL|GO|GRID|GROUP|HEADING|HIGHLIGHT|HIGH-VALUE|HIGH-VALUES|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINES|LINE-COUNTER|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOWER|LOWLIGHT|LOW-VALUE|LOW-VALUES|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|POSITION|POSITIVE|PORT|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|READER|REMOTE|RD|REAL|READ|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|REVERSE-VIDEO|RESET|RETURN|RETURN-CODE|RETURNING|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TASK|TAPE|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYMMDD|YYYYDDD|ZERO-FILL|ZEROS|ZEROES)(?![\w-])/i,
          lookbehind: true
        },
        boolean: {
          pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i,
          lookbehind: true
        },
        number: {
          pattern: /(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
          lookbehind: true
        },
        operator: [
          /<>|[<>]=?|[=+*/&]/,
          {
            pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
            lookbehind: true
          }
        ],
        punctuation: /[.:,()]/
      };
    }
  }
});

// node_modules/refractor/lang/coq.js
var require_coq = __commonJS({
  "node_modules/refractor/lang/coq.js"(exports, module) {
    "use strict";
    module.exports = coq;
    coq.displayName = "coq";
    coq.aliases = [];
    function coq(Prism) {
      ;
      (function(Prism2) {
        var commentSource = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source;
        for (var i = 0; i < 2; i++) {
          commentSource = commentSource.replace(/<self>/g, function() {
            return commentSource;
          });
        }
        commentSource = commentSource.replace(/<self>/g, "[]");
        Prism2.languages.coq = {
          comment: RegExp(commentSource),
          string: {
            pattern: /"(?:[^"]|"")*"(?!")/,
            greedy: true
          },
          attribute: [
            {
              pattern: RegExp(
                /#\[(?:[^\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(
                  /<comment>/g,
                  function() {
                    return commentSource;
                  }
                )
              ),
              greedy: true,
              alias: "attr-name",
              inside: {
                comment: RegExp(commentSource),
                string: {
                  pattern: /"(?:[^"]|"")*"(?!")/,
                  greedy: true
                },
                operator: /=/,
                punctuation: /^#\[|\]$|[,()]/
              }
            },
            {
              pattern: /\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
              alias: "attr-name"
            }
          ],
          keyword: /\b(?:_|Abort|About|Add|Admit|Admitted|All|apply|Arguments|as|As|Assumptions|at|Axiom|Axioms|Back|BackTo|Backtrace|Bind|BinOp|BinOpSpec|BinRel|Blacklist|by|Canonical|Case|Cd|Check|Class|Classes|Close|Coercion|Coercions|cofix|CoFixpoint|CoInductive|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|else|end|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|exists|exists2|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|fix|Fixpoint|Flags|Focus|for|forall|From|fun|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|Identity|if|IF|Immediate|Implicit|Implicits|Import|in|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|let|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|match|Match|measure|Method|Minimality|ML|Module|Modules|Morphism|move|Next|NoInline|Notation|Number|Obligation|Obligations|OCaml|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|Property|PropOp|Proposition|PropUOp|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|removed|Require|Reserved|Reset|Resolve|Restart|return|Rewrite|Right|Ring|Rings|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|SProp|Step|Strategies|Strategy|String|struct|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|then|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|UnOp|UnOpSpec|Unshelve|using|Variable|Variables|Variant|Verbose|View|Visibility|wf|where|with|Zify)\b/,
          number: /\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
          punct: {
            pattern: /@\{|\{\||\[=|:>/,
            alias: "punctuation"
          },
          operator: /\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
          punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
        };
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/cshtml.js
var require_cshtml = __commonJS({
  "node_modules/refractor/lang/cshtml.js"(exports, module) {
    "use strict";
    var refractorCsharp = require_csharp();
    module.exports = cshtml;
    cshtml.displayName = "cshtml";
    cshtml.aliases = ["razor"];
    function cshtml(Prism) {
      Prism.register(refractorCsharp);
      (function(Prism2) {
        var commentLike = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source;
        var stringLike = /@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source + "|" + /'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
        function nested(pattern, depthLog2) {
          for (var i = 0; i < depthLog2; i++) {
            pattern = pattern.replace(/<self>/g, function() {
              return "(?:" + pattern + ")";
            });
          }
          return pattern.replace(/<self>/g, "[^\\s\\S]").replace(/<str>/g, "(?:" + stringLike + ")").replace(/<comment>/g, "(?:" + commentLike + ")");
        }
        var round = nested(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2);
        var square = nested(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 2);
        var curly = nested(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2);
        var angle = nested(/<(?:[^<>'"@/]|<str>|<comment>|<self>)*>/.source, 2);
        var tagAttrs = /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?/.source;
        var tagContent = /(?!\d)[^\s>\/=$<%]+/.source + tagAttrs + /\s*\/?>/.source;
        var tagRegion = /\B@?/.source + "(?:" + /<([a-zA-Z][\w:]*)/.source + tagAttrs + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
        // eslint-disable-next-line regexp/strict
        /<\/?(?!\1\b)/.source + tagContent + "|" + // nested start tag
        nested(
          // eslint-disable-next-line regexp/strict
          /<\1/.source + tagAttrs + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
          // eslint-disable-next-line regexp/strict
          /<\/?(?!\1\b)/.source + tagContent + "|<self>") + ")*" + // eslint-disable-next-line regexp/strict
          /<\/\1\s*>/.source,
          2
        )) + ")*" + // eslint-disable-next-line regexp/strict
        /<\/\1\s*>/.source + "|" + /</.source + tagContent + ")";
        Prism2.languages.cshtml = Prism2.languages.extend("markup", {});
        var csharpWithHtml = Prism2.languages.insertBefore(
          "csharp",
          "string",
          {
            html: {
              pattern: RegExp(tagRegion),
              greedy: true,
              inside: Prism2.languages.cshtml
            }
          },
          {
            csharp: Prism2.languages.extend("csharp", {})
          }
        );
        var cs = {
          pattern: /\S[\s\S]*/,
          alias: "language-csharp",
          inside: csharpWithHtml
        };
        Prism2.languages.insertBefore("cshtml", "prolog", {
          "razor-comment": {
            pattern: /@\*[\s\S]*?\*@/,
            greedy: true,
            alias: "comment"
          },
          block: {
            pattern: RegExp(
              /(^|[^@])@/.source + "(?:" + [
                // @{ ... }
                curly,
                // @code{ ... }
                /(?:code|functions)\s*/.source + curly,
                // @for (...) { ... }
                /(?:for|foreach|lock|switch|using|while)\s*/.source + round + /\s*/.source + curly,
                // @do { ... } while (...);
                /do\s*/.source + curly + /\s*while\s*/.source + round + /(?:\s*;)?/.source,
                // @try { ... } catch (...) { ... } finally { ... }
                /try\s*/.source + curly + /\s*catch\s*/.source + round + /\s*/.source + curly + /\s*finally\s*/.source + curly,
                // @if (...) {...} else if (...) {...} else {...}
                /if\s*/.source + round + /\s*/.source + curly + "(?:" + /\s*else/.source + "(?:" + /\s+if\s*/.source + round + ")?" + /\s*/.source + curly + ")*"
              ].join("|") + ")"
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              keyword: /^@\w*/,
              csharp: cs
            }
          },
          directive: {
            pattern: /^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
            lookbehind: true,
            greedy: true,
            inside: {
              keyword: /^@\w+/,
              csharp: cs
            }
          },
          value: {
            pattern: RegExp(
              /(^|[^@])@/.source + /(?:await\b\s*)?/.source + "(?:" + /\w+\b/.source + "|" + round + ")(?:" + /[?!]?\.\w+\b/.source + "|" + round + "|" + square + "|" + angle + round + ")*"
            ),
            lookbehind: true,
            greedy: true,
            alias: "variable",
            inside: {
              keyword: /^@/,
              csharp: cs
            }
          },
          "delegate-operator": {
            pattern: /(^|[^@])@(?=<)/,
            lookbehind: true,
            alias: "operator"
          }
        });
        Prism2.languages.razor = Prism2.languages.cshtml;
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/csv.js
var require_csv = __commonJS({
  "node_modules/refractor/lang/csv.js"(exports, module) {
    "use strict";
    module.exports = csv;
    csv.displayName = "csv";
    csv.aliases = [];
    function csv(Prism) {
      Prism.languages.csv = {
        value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
        punctuation: /,/
      };
    }
  }
});

// node_modules/refractor/lang/dataweave.js
var require_dataweave = __commonJS({
  "node_modules/refractor/lang/dataweave.js"(exports, module) {
    "use strict";
    module.exports = dataweave;
    dataweave.displayName = "dataweave";
    dataweave.aliases = [];
    function dataweave(Prism) {
      ;
      (function(Prism2) {
        Prism2.languages.dataweave = {
          url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
          property: {
            pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
            greedy: true
          },
          string: {
            pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
            greedy: true
          },
          "mime-type": /\b(?:text|audio|video|application|multipart|image)\/[\w+-]+/,
          date: {
            pattern: /\|[\w:+-]+\|/,
            greedy: true
          },
          comment: [
            {
              pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
              lookbehind: true,
              greedy: true
            },
            {
              pattern: /(^|[^\\:])\/\/.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          regex: {
            pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//,
            greedy: true
          },
          function: /\b[A-Z_]\w*(?=\s*\()/i,
          number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
          punctuation: /[{}[\];(),.:@]/,
          operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
          boolean: /\b(?:true|false)\b/,
          keyword: /\b(?:match|input|output|ns|type|update|null|if|else|using|unless|at|is|as|case|do|fun|var|not|and|or)\b/
        };
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/dot.js
var require_dot = __commonJS({
  "node_modules/refractor/lang/dot.js"(exports, module) {
    "use strict";
    module.exports = dot;
    dot.displayName = "dot";
    dot.aliases = ["gv"];
    function dot(Prism) {
      ;
      (function(Prism2) {
        var ID = "(?:" + [
          // an identifier
          /[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
          // a number
          /-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
          // a double-quoted string
          /"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
          // HTML-like string
          /<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
        ].join("|") + ")";
        var IDInside = {
          markup: {
            pattern: /(^<)[\s\S]+(?=>$)/,
            lookbehind: true,
            alias: ["language-markup", "language-html", "language-xml"],
            inside: Prism2.languages.markup
          }
        };
        function withID(source, flags) {
          return RegExp(
            source.replace(/<ID>/g, function() {
              return ID;
            }),
            flags
          );
        }
        Prism2.languages.dot = {
          comment: {
            pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
            greedy: true
          },
          "graph-name": {
            pattern: withID(
              /(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source,
              "i"
            ),
            lookbehind: true,
            greedy: true,
            alias: "class-name",
            inside: IDInside
          },
          "attr-value": {
            pattern: withID(/(=[ \t\r\n]*)<ID>/.source),
            lookbehind: true,
            greedy: true,
            inside: IDInside
          },
          "attr-name": {
            pattern: withID(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
            lookbehind: true,
            greedy: true,
            inside: IDInside
          },
          keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
          "compass-point": {
            pattern: /(:[ \t\r\n]*)(?:[ns][ew]?|[ewc_])(?![\w\x80-\uFFFF])/,
            lookbehind: true,
            alias: "builtin"
          },
          node: {
            pattern: withID(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
            lookbehind: true,
            greedy: true,
            inside: IDInside
          },
          operator: /[=:]|-[->]/,
          punctuation: /[\[\]{};,]/
        };
        Prism2.languages.gv = Prism2.languages.dot;
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/false.js
var require_false = __commonJS({
  "node_modules/refractor/lang/false.js"(exports, module) {
    "use strict";
    module.exports = $false;
    $false.displayName = "$false";
    $false.aliases = [];
    function $false(Prism) {
      ;
      (function(Prism2) {
        Prism2.languages["false"] = {
          comment: {
            pattern: /\{[^}]*\}/
          },
          string: {
            pattern: /"[^"]*"/,
            greedy: true
          },
          "character-code": {
            pattern: /'(?:[^\r]|\r\n?)/,
            alias: "number"
          },
          "assembler-code": {
            pattern: /\d+`/,
            alias: "important"
          },
          number: /\d+/,
          operator: /[-!#$%&'*+,./:;=>?@\\^_`|~ßø]/,
          punctuation: /\[|\]/,
          variable: /[a-z]/,
          "non-standard": {
            pattern: /[()<BDO®]/,
            alias: "bold"
          }
        };
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/gap.js
var require_gap = __commonJS({
  "node_modules/refractor/lang/gap.js"(exports, module) {
    "use strict";
    module.exports = gap;
    gap.displayName = "gap";
    gap.aliases = [];
    function gap(Prism) {
      Prism.languages.gap = {
        shell: {
          pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
          greedy: true,
          inside: {
            gap: {
              pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
              lookbehind: true,
              inside: null
              // see below
            },
            punctuation: /^gap>/
          }
        },
        comment: {
          pattern: /#.*/,
          greedy: true
        },
        string: {
          pattern: /(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
          lookbehind: true,
          greedy: true,
          inside: {
            continuation: {
              pattern: /([\r\n])>/,
              lookbehind: true,
              alias: "punctuation"
            }
          }
        },
        keyword: /\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
        boolean: /\b(?:false|true)\b/,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: {
          pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
          lookbehind: true
        },
        continuation: {
          pattern: /([\r\n])>/,
          lookbehind: true,
          alias: "punctuation"
        },
        operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
        punctuation: /[()[\]{},;.:]/
      };
      Prism.languages.gap.shell.inside.gap.inside = Prism.languages.gap;
    }
  }
});

// node_modules/refractor/lang/gn.js
var require_gn = __commonJS({
  "node_modules/refractor/lang/gn.js"(exports, module) {
    "use strict";
    module.exports = gn;
    gn.displayName = "gn";
    gn.aliases = ["gni"];
    function gn(Prism) {
      Prism.languages.gn = {
        comment: {
          pattern: /#.*/,
          greedy: true
        },
        "string-literal": {
          pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
          lookbehind: true,
          greedy: true,
          inside: {
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
              lookbehind: true,
              inside: {
                number: /^\$0x[\s\S]{2}$/,
                variable: /^\$\w+$/,
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                expression: {
                  pattern: /[\s\S]+/,
                  inside: null
                  // see below
                }
              }
            },
            string: /[\s\S]+/
          }
        },
        keyword: /\b(?:else|if)\b/,
        boolean: /\b(?:true|false)\b/,
        "builtin-function": {
          // a few functions get special highlighting to improve readability
          pattern: /\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
          alias: "keyword"
        },
        function: /\b[a-z_]\w*(?=\s*\()/i,
        constant: /\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_out_dir|target_os)\b/,
        number: /-?\b\d+\b/,
        operator: /[-+!=<>]=?|&&|\|\|/,
        punctuation: /[(){}[\],.]/
      };
      Prism.languages.gn["string-literal"].inside["interpolation"].inside["expression"].inside = Prism.languages.gn;
      Prism.languages.gni = Prism.languages.gn;
    }
  }
});

// node_modules/refractor/lang/hoon.js
var require_hoon = __commonJS({
  "node_modules/refractor/lang/hoon.js"(exports, module) {
    "use strict";
    module.exports = hoon;
    hoon.displayName = "hoon";
    hoon.aliases = [];
    function hoon(Prism) {
      Prism.languages.hoon = {
        constant: /%(?:\.[ny]|[\w-]+)/,
        comment: {
          pattern: /::.*/,
          greedy: true
        },
        "class-name": [
          {
            pattern: /@(?:[A-Za-z0-9-]*[A-Za-z0-9])?/
          },
          /\*/
        ],
        function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        keyword: /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
      };
    }
  }
});

// node_modules/refractor/lang/icu-message-format.js
var require_icu_message_format = __commonJS({
  "node_modules/refractor/lang/icu-message-format.js"(exports, module) {
    "use strict";
    module.exports = icuMessageFormat;
    icuMessageFormat.displayName = "icuMessageFormat";
    icuMessageFormat.aliases = [];
    function icuMessageFormat(Prism) {
      ;
      (function(Prism2) {
        function nested(source, level) {
          if (level <= 0) {
            return /[]/.source;
          } else {
            return source.replace(/<SELF>/g, function() {
              return nested(source, level - 1);
            });
          }
        }
        var stringPattern = /'[{}:=,](?:[^']|'')*'(?!')/;
        var escape = {
          pattern: /''/,
          greedy: true,
          alias: "operator"
        };
        var string = {
          pattern: stringPattern,
          greedy: true,
          inside: {
            escape
          }
        };
        var argumentSource = nested(
          /\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(
            /<STR>/g,
            function() {
              return stringPattern.source;
            }
          ),
          8
        );
        var nestedMessage = {
          pattern: RegExp(argumentSource),
          inside: {
            message: {
              pattern: /^(\{)[\s\S]+(?=\}$)/,
              lookbehind: true,
              inside: null
              // see below
            },
            "message-delimiter": {
              pattern: /./,
              alias: "punctuation"
            }
          }
        };
        Prism2.languages["icu-message-format"] = {
          argument: {
            pattern: RegExp(argumentSource),
            greedy: true,
            inside: {
              content: {
                pattern: /^(\{)[\s\S]+(?=\}$)/,
                lookbehind: true,
                inside: {
                  "argument-name": {
                    pattern: /^(\s*)[^{}:=,\s]+/,
                    lookbehind: true
                  },
                  "choice-style": {
                    // https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1ChoiceFormat.html#details
                    pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
                    lookbehind: true,
                    inside: {
                      punctuation: /\|/,
                      range: {
                        pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
                        lookbehind: true,
                        inside: {
                          operator: /[<#\u2264]/,
                          number: /\S+/
                        }
                      },
                      rest: null
                      // see below
                    }
                  },
                  "plural-style": {
                    // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/PluralFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                    pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
                    lookbehind: true,
                    inside: {
                      offset: /^offset:\s*\d+/,
                      "nested-message": nestedMessage,
                      selector: {
                        pattern: /=\d+|[^{}:=,\s]+/,
                        inside: {
                          keyword: /^(?:zero|one|two|few|many|other)$/
                        }
                      }
                    }
                  },
                  "select-style": {
                    // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/SelectFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                    pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
                    lookbehind: true,
                    inside: {
                      "nested-message": nestedMessage,
                      selector: {
                        pattern: /[^{}:=,\s]+/,
                        inside: {
                          keyword: /^other$/
                        }
                      }
                    }
                  },
                  keyword: /\b(?:choice|plural|select|selectordinal)\b/,
                  "arg-type": {
                    pattern: /\b(?:number|date|time|spellout|ordinal|duration)\b/,
                    alias: "keyword"
                  },
                  "arg-skeleton": {
                    pattern: /(,\s*)::[^{}:=,\s]+/,
                    lookbehind: true
                  },
                  "arg-style": {
                    pattern: /(,\s*)(?:short|medium|long|full|integer|currency|percent)(?=\s*$)/,
                    lookbehind: true
                  },
                  "arg-style-text": {
                    pattern: RegExp(
                      /(^\s*,\s*(?=\S))/.source + nested(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) + "$"
                    ),
                    lookbehind: true,
                    alias: "string"
                  },
                  punctuation: /,/
                }
              },
              "argument-delimiter": {
                pattern: /./,
                alias: "operator"
              }
            }
          },
          escape,
          string
        };
        nestedMessage.inside.message.inside = Prism2.languages["icu-message-format"];
        Prism2.languages["icu-message-format"].argument.inside.content.inside["choice-style"].inside.rest = Prism2.languages["icu-message-format"];
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/idris.js
var require_idris = __commonJS({
  "node_modules/refractor/lang/idris.js"(exports, module) {
    "use strict";
    var refractorHaskell = require_haskell();
    module.exports = idris;
    idris.displayName = "idris";
    idris.aliases = ["idr"];
    function idris(Prism) {
      Prism.register(refractorHaskell);
      Prism.languages.idris = Prism.languages.extend("haskell", {
        comment: {
          pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m
        },
        keyword: /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
        "import-statement": {
          pattern: /(^\s*)import\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
          lookbehind: true
        },
        builtin: void 0
      });
      Prism.languages.idr = Prism.languages.idris;
    }
  }
});

// node_modules/refractor/lang/jexl.js
var require_jexl = __commonJS({
  "node_modules/refractor/lang/jexl.js"(exports, module) {
    "use strict";
    module.exports = jexl;
    jexl.displayName = "jexl";
    jexl.aliases = [];
    function jexl(Prism) {
      Prism.languages.jexl = {
        string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
        transform: {
          pattern: /(\|\s*)[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
          alias: "function",
          lookbehind: true
        },
        function: /[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
        number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
        operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
        boolean: /\b(?:true|false)\b/,
        keyword: /\bin\b/,
        punctuation: /[{}[\](),.]/
      };
    }
  }
});

// node_modules/refractor/lang/kumir.js
var require_kumir = __commonJS({
  "node_modules/refractor/lang/kumir.js"(exports, module) {
    "use strict";
    module.exports = kumir;
    kumir.displayName = "kumir";
    kumir.aliases = ["kum"];
    function kumir(Prism) {
      ;
      (function(Prism2) {
        var nonId = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
        function wrapId(pattern, flags) {
          return RegExp(pattern.replace(/<nonId>/g, nonId), flags);
        }
        Prism2.languages.kumir = {
          comment: {
            pattern: /\|.*/
          },
          prolog: {
            pattern: /#.*/,
            greedy: true
          },
          string: {
            pattern: /"[^\n\r"]*"|'[^\n\r']*'/,
            greedy: true
          },
          boolean: {
            pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),
            lookbehind: true
          },
          "operator-word": {
            pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),
            lookbehind: true,
            alias: "keyword"
          },
          "system-variable": {
            pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),
            lookbehind: true,
            alias: "keyword"
          },
          type: [
            {
              pattern: wrapId(
                /(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\x20*таб)?(?=[<nonId>]|$)/.source
              ),
              lookbehind: true,
              alias: "builtin"
            },
            {
              pattern: wrapId(
                /(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source
              ),
              lookbehind: true,
              alias: "important"
            }
          ],
          /**
           * Should be performed after searching for type names because of "таб".
           * "таб" is a reserved word, but never used without a preceding type name.
           * "НАЗНАЧИТЬ", "Фввод", and "Фвывод" are not reserved words.
           */
          keyword: {
            pattern: wrapId(
              /(^|[<nonId>])(?:алг|арг(?:\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\x20+|_)исп)?|кц(?:(?:\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source
            ),
            lookbehind: true
          },
          /** Should be performed after searching for reserved words. */
          name: {
            // eslint-disable-next-line regexp/no-super-linear-backtracking
            pattern: wrapId(
              /(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source
            ),
            lookbehind: true
          },
          /** Should be performed after searching for names. */
          number: {
            pattern: wrapId(
              /(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/.source,
              "i"
            ),
            lookbehind: true
          },
          /** Should be performed after searching for words. */
          punctuation: /:=|[(),:;\[\]]/,
          /**
           * Should be performed after searching for
           * - numeric constants (because of "+" and "-");
           * - punctuation marks (because of ":=" and "=").
           */
          "operator-char": {
            pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
            alias: "operator"
          }
        };
        Prism2.languages.kum = Prism2.languages.kumir;
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/kusto.js
var require_kusto = __commonJS({
  "node_modules/refractor/lang/kusto.js"(exports, module) {
    "use strict";
    module.exports = kusto;
    kusto.displayName = "kusto";
    kusto.aliases = [];
    function kusto(Prism) {
      Prism.languages.kusto = {
        comment: {
          pattern: /\/\/.*/,
          greedy: true
        },
        string: {
          pattern: /```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
          greedy: true
        },
        verb: {
          pattern: /(\|\s*)[a-z][\w-]*/i,
          lookbehind: true,
          alias: "keyword"
        },
        command: {
          pattern: /\.[a-z][a-z\d-]*\b/,
          alias: "keyword"
        },
        "class-name": /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
        keyword: /\b(?:access|alias|and|anti|as|asc|auto|between|by|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|(?:has(?:perfix|suffix)?|contains|(?:starts|ends)with)(?:_cs)?|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
        boolean: /\b(?:true|false|null)\b/,
        function: /\b[a-z_]\w*(?=\s*\()/,
        datetime: [
          {
            // RFC 822 + RFC 850
            pattern: /\b(?:(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:(?:U|GM|[ECMT][DS])T|[A-Z])|[+-]\d{4}))?\b/,
            alias: "number"
          },
          {
            // ISO 8601
            pattern: /[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
            alias: "number"
          }
        ],
        number: /\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mnµ]s|tick|microsecond|[dhms])\b)?|[+-]?\binf\b/,
        operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
        punctuation: /[()\[\]{},;.:]/
      };
    }
  }
});

// node_modules/refractor/lang/log.js
var require_log = __commonJS({
  "node_modules/refractor/lang/log.js"(exports, module) {
    "use strict";
    module.exports = log;
    log.displayName = "log";
    log.aliases = [];
    function log(Prism) {
      Prism.languages.log = {
        string: {
          // Single-quoted strings must not be confused with plain text. E.g. Can't isn't Susan's Chris' toy
          pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
          greedy: true
        },
        exception: {
          pattern: /(^|[^\w.])[a-z][\w.]*(?:Exception|Error):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
          lookbehind: true,
          greedy: true,
          alias: ["javastacktrace", "language-javastacktrace"],
          inside: Prism.languages["javastacktrace"] || {
            keyword: /\bat\b/,
            function: /[a-z_][\w$]*(?=\()/,
            punctuation: /[.:()]/
          }
        },
        level: [
          {
            pattern: /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
            alias: ["error", "important"]
          },
          {
            pattern: /\b(?:WARN|WARNING|WRN)\b/,
            alias: ["warning", "important"]
          },
          {
            pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
            alias: ["info", "keyword"]
          },
          {
            pattern: /\b(?:DBG|DEBUG|FINE)\b/,
            alias: ["debug", "keyword"]
          },
          {
            pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
            alias: ["trace", "comment"]
          }
        ],
        property: {
          pattern: /((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
          lookbehind: true
        },
        separator: {
          pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
          lookbehind: true,
          alias: "comment"
        },
        url: /\b(?:https?|ftp|file):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
        email: {
          pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
          lookbehind: true,
          alias: "url"
        },
        "ip-address": {
          pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/i,
          alias: "constant"
        },
        "mac-address": {
          pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
          alias: "constant"
        },
        domain: {
          pattern: /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
          lookbehind: true,
          alias: "constant"
        },
        uuid: {
          pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
          alias: "constant"
        },
        hash: {
          pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i,
          alias: "constant"
        },
        "file-path": {
          pattern: /\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
          lookbehind: true,
          greedy: true,
          alias: "string"
        },
        date: {
          pattern: RegExp(
            /\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source + "|" + /\b\d{1,4}[-/ ](?:\d{1,2}|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[-/ ]\d{2,4}T?\b/.source + "|" + /\b(?:(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)(?:\s{1,2}(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))?|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s{1,2}\d{1,2}\b/.source,
            "i"
          ),
          alias: "number"
        },
        time: {
          pattern: /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
          alias: "number"
        },
        boolean: /\b(?:true|false|null)\b/i,
        number: {
          pattern: /(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
          lookbehind: true
        },
        operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
        punctuation: /[\[\].,]/
      };
    }
  }
});

// node_modules/refractor/lang/magma.js
var require_magma = __commonJS({
  "node_modules/refractor/lang/magma.js"(exports, module) {
    "use strict";
    module.exports = magma;
    magma.displayName = "magma";
    magma.aliases = [];
    function magma(Prism) {
      Prism.languages.magma = {
        output: {
          pattern: /^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
          lookbehind: true,
          greedy: true
        },
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
          greedy: true
        },
        string: {
          pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
          lookbehind: true,
          greedy: true
        },
        // http://magma.maths.usyd.edu.au/magma/handbook/text/82
        keyword: /\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
        boolean: /\b(?:false|true)\b/,
        generator: {
          pattern: /\b[a-z_]\w*(?=\s*<)/i,
          alias: "class-name"
        },
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: {
          pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
          lookbehind: true
        },
        operator: /->|[-+*/^~!|#=]|:=|\.\./,
        punctuation: /[()[\]{}<>,;.:]/
      };
    }
  }
});

// node_modules/refractor/lang/maxscript.js
var require_maxscript = __commonJS({
  "node_modules/refractor/lang/maxscript.js"(exports, module) {
    "use strict";
    module.exports = maxscript;
    maxscript.displayName = "maxscript";
    maxscript.aliases = [];
    function maxscript(Prism) {
      Prism.languages.maxscript = {
        comment: {
          pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
          greedy: true
        },
        string: {
          pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
          lookbehind: true,
          greedy: true
        },
        path: {
          pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
          greedy: true,
          alias: "string"
        },
        "function-definition": {
          pattern: /(\b(?:function|fn)\s+)\w+\b/,
          lookbehind: true,
          alias: "function"
        },
        argument: {
          pattern: /\b[a-z_]\w*(?=:)/i,
          alias: "attr-name"
        },
        keyword: /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i,
        boolean: /\b(?:true|false|on|off)\b/,
        time: {
          pattern: /(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
          lookbehind: true,
          alias: "number"
        },
        number: [
          {
            pattern: /(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
            lookbehind: true
          },
          /\b(?:e|pi)\b/
        ],
        constant: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/,
        color: {
          pattern: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/i,
          alias: "constant"
        },
        operator: /[-+*/<>=!]=?|[&^]|#(?!\()/,
        punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
      };
    }
  }
});

// node_modules/refractor/lang/mermaid.js
var require_mermaid = __commonJS({
  "node_modules/refractor/lang/mermaid.js"(exports, module) {
    "use strict";
    module.exports = mermaid;
    mermaid.displayName = "mermaid";
    mermaid.aliases = [];
    function mermaid(Prism) {
      Prism.languages.mermaid = {
        comment: {
          pattern: /%%.*/,
          greedy: true
        },
        style: {
          pattern: /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
          lookbehind: true,
          inside: {
            property: /\b\w[\w-]*(?=[ \t]*:)/,
            operator: /:/,
            punctuation: /,/
          }
        },
        "inter-arrow-label": {
          pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
          lookbehind: true,
          greedy: true,
          inside: {
            arrow: {
              pattern: /(?:\.+->?|--+[->]|==+[=>])$/,
              alias: "operator"
            },
            label: {
              pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
              lookbehind: true,
              alias: "property"
            },
            "arrow-head": {
              pattern: /^\S+/,
              alias: ["arrow", "operator"]
            }
          }
        },
        arrow: [
          // This might look complex but it really isn't.
          // There are many possible arrows (see tests) and it's impossible to fit all of them into one pattern. The
          // problem is that we only have one lookbehind per pattern. However, we cannot disallow too many arrow
          // characters in the one lookbehind because that would create too many false negatives. So we have to split the
          // arrows into different patterns.
          {
            // ER diagram
            pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
            lookbehind: true,
            alias: "operator"
          },
          {
            // flow chart
            // (?:==+|--+|-\.*-)
            pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
            lookbehind: true,
            alias: "operator"
          },
          {
            // sequence diagram
            pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
            lookbehind: true,
            alias: "operator"
          },
          {
            // class diagram
            pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
            lookbehind: true,
            alias: "operator"
          }
        ],
        label: {
          pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
          lookbehind: true,
          greedy: true,
          alias: "property"
        },
        text: {
          pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
          alias: "string"
        },
        string: {
          pattern: /"[^"\r\n]*"/,
          greedy: true
        },
        annotation: {
          pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
          alias: "important"
        },
        keyword: [
          // This language has both case-sensitive and case-insensitive keywords
          {
            pattern: /(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
            lookbehind: true,
            greedy: true
          }
        ],
        entity: /#[a-z0-9]+;/,
        operator: {
          pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/,
          lookbehind: true
        },
        punctuation: /[(){};]/
      };
    }
  }
});

// node_modules/refractor/lang/nevod.js
var require_nevod = __commonJS({
  "node_modules/refractor/lang/nevod.js"(exports, module) {
    "use strict";
    module.exports = nevod;
    nevod.displayName = "nevod";
    nevod.aliases = [];
    function nevod(Prism) {
      Prism.languages.nevod = {
        comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
        string: {
          pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
          greedy: true,
          inside: {
            "string-attrs": /!$|!\*$|\*$/
          }
        },
        namespace: {
          pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
          lookbehind: true
        },
        pattern: {
          pattern: /(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
          lookbehind: true,
          inside: {
            "pattern-name": {
              pattern: /^#?[a-zA-Z0-9\-.]+/,
              alias: "class-name"
            },
            fields: {
              pattern: /\(.*\)/,
              inside: {
                "field-name": {
                  pattern: /[a-zA-Z0-9\-.]+/,
                  alias: "variable"
                },
                punctuation: /[,()]/,
                operator: {
                  pattern: /~/,
                  alias: "field-hidden-mark"
                }
              }
            }
          }
        },
        search: {
          pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
          alias: "function",
          lookbehind: true
        },
        keyword: /@(?:require|namespace|pattern|search|inside|outside|having|where)\b/,
        "standard-pattern": {
          pattern: /\b(?:Word|Punct|Symbol|Space|LineBreak|Start|End|Alpha|AlphaNum|Num|NumAlpha|Blank|WordBreak|Any)(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
          inside: {
            "standard-pattern-name": {
              pattern: /^[a-zA-Z0-9\-.]+/,
              alias: "builtin"
            },
            quantifier: {
              pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
              alias: "number"
            },
            "standard-pattern-attr": {
              pattern: /[a-zA-Z0-9\-.]+/,
              alias: "builtin"
            },
            punctuation: /[,()]/
          }
        },
        quantifier: {
          pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
          alias: "number"
        },
        operator: [
          {
            pattern: /=/,
            alias: "pattern-def"
          },
          {
            pattern: /&/,
            alias: "conjunction"
          },
          {
            pattern: /~/,
            alias: "exception"
          },
          {
            pattern: /\?/,
            alias: "optionality"
          },
          {
            pattern: /[[\]]/,
            alias: "repetition"
          },
          {
            pattern: /[{}]/,
            alias: "variation"
          },
          {
            pattern: /[+_]/,
            alias: "sequence"
          },
          {
            pattern: /\.{2,3}/,
            alias: "span"
          }
        ],
        "field-capture": [
          {
            pattern: /([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
            lookbehind: true,
            inside: {
              "field-name": {
                pattern: /[a-zA-Z0-9\-.]+/,
                alias: "variable"
              },
              colon: /:/
            }
          },
          {
            pattern: /[a-zA-Z0-9\-.]+\s*:/,
            inside: {
              "field-name": {
                pattern: /[a-zA-Z0-9\-.]+/,
                alias: "variable"
              },
              colon: /:/
            }
          }
        ],
        punctuation: /[:;,()]/,
        name: /[a-zA-Z0-9\-.]+/
      };
    }
  }
});

// node_modules/refractor/lang/openqasm.js
var require_openqasm = __commonJS({
  "node_modules/refractor/lang/openqasm.js"(exports, module) {
    "use strict";
    module.exports = openqasm;
    openqasm.displayName = "openqasm";
    openqasm.aliases = ["qasm"];
    function openqasm(Prism) {
      Prism.languages.openqasm = {
        comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
        string: {
          pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/,
          greedy: true
        },
        keyword: /\b(?:barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while|CX|OPENQASM|U)\b|#pragma\b/,
        "class-name": /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
        function: /\b(?:sin|cos|tan|exp|ln|sqrt|rotl|rotr|popcount)\b(?=\s*\()/,
        constant: /\b(?:pi|tau|euler)\b|π|𝜏|ℇ/,
        number: {
          pattern: /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|µs|ms|s)?/i,
          lookbehind: true
        },
        operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
        punctuation: /[(){}\[\];,:.]/
      };
      Prism.languages.qasm = Prism.languages.openqasm;
    }
  }
});

// node_modules/refractor/lang/promql.js
var require_promql = __commonJS({
  "node_modules/refractor/lang/promql.js"(exports, module) {
    "use strict";
    module.exports = promql;
    promql.displayName = "promql";
    promql.aliases = [];
    function promql(Prism) {
      ;
      (function(Prism2) {
        var aggregations = [
          "sum",
          "min",
          "max",
          "avg",
          "group",
          "stddev",
          "stdvar",
          "count",
          "count_values",
          "bottomk",
          "topk",
          "quantile"
        ];
        var vectorMatching = [
          "on",
          "ignoring",
          "group_right",
          "group_left",
          "by",
          "without"
        ];
        var offsetModifier = ["offset"];
        var keywords = aggregations.concat(vectorMatching, offsetModifier);
        Prism2.languages.promql = {
          comment: {
            pattern: /(^[ \t]*)#.*/m,
            lookbehind: true
          },
          "vector-match": {
            // Match the comma-separated label lists inside vector matching:
            pattern: new RegExp(
              "((?:" + vectorMatching.join("|") + ")\\s*)\\([^)]*\\)"
            ),
            lookbehind: true,
            inside: {
              "label-key": {
                pattern: /\b[^,]+\b/,
                alias: "attr-name"
              },
              punctuation: /[(),]/
            }
          },
          "context-labels": {
            pattern: /\{[^{}]*\}/,
            inside: {
              "label-key": {
                pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
                alias: "attr-name"
              },
              "label-value": {
                pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
                greedy: true,
                alias: "attr-value"
              },
              punctuation: /\{|\}|=~?|![=~]|,/
            }
          },
          "context-range": [
            {
              pattern: /\[[\w\s:]+\]/,
              // [1m]
              inside: {
                punctuation: /\[|\]|:/,
                "range-duration": {
                  pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
                  alias: "number"
                }
              }
            },
            {
              pattern: /(\boffset\s+)\w+/,
              // offset 1m
              lookbehind: true,
              inside: {
                "range-duration": {
                  pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
                  alias: "number"
                }
              }
            }
          ],
          keyword: new RegExp("\\b(?:" + keywords.join("|") + ")\\b", "i"),
          function: /\b[a-z_]\w*(?=\s*\()/i,
          number: /[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
          operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|unless|or)\b/i,
          punctuation: /[{};()`,.[\]]/
        };
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/psl.js
var require_psl = __commonJS({
  "node_modules/refractor/lang/psl.js"(exports, module) {
    "use strict";
    module.exports = psl;
    psl.displayName = "psl";
    psl.aliases = [];
    function psl(Prism) {
      Prism.languages.psl = {
        comment: {
          pattern: /#.*/,
          greedy: true
        },
        string: {
          pattern: /"(?:\\.|[^\\"])*"/,
          greedy: true,
          inside: {
            symbol: /\\[ntrbA-Z"\\]/
          }
        },
        "heredoc-string": {
          pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
          alias: "string",
          greedy: true
        },
        keyword: /\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
        constant: /\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|FALSE|False|false|NO|No|no|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|TRUE|True|true|VOID|WARN)\b/,
        variable: /\b(?:errno|exit_status|PslDebug)\b/,
        builtin: {
          pattern: /\b(?:acos|add_diary|annotate|annotate_get|asctime|asin|atan|atexit|ascii_to_ebcdic|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|destroy_lock|dump_hist|date|destroy|difference|dget_text|dcget_text|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|floor|fmod|full_discovery|file|fopen|ftell|fseek|grep|get_vars|getenv|get|get_chan_info|get_ranges|get_text|gethostinfo|getpid|getpname|history_get_retention|history|index|int|is_var|intersection|isnumber|internal|in_transition|join|kill|length|lines|lock|lock_info|log|loge|log10|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|num_consoles|nthargf|nthline|nthlinef|num_bytes|print|proc_exists|process|popen|printf|pconfig|poplines|pow|PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|sopen|sqrt|srandom|subset|set|substr|system|sprintf|sort|snmp_agent_config|_snmp_debug|snmp_agent_stop|snmp_agent_start|snmp_h_set|snmp_h_get_next|snmp_h_get|snmp_set|snmp_walk|snmp_get_next|snmp_get|snmp_config|snmp_close|snmp_open|snmp_trap_receive|snmp_trap_ignore|snmp_trap_listen|snmp_trap_send|snmp_trap_raise_std_trap|snmp_trap_register_im|splitline|strcasecmp|str_repeat|trim|tail|tan|tanh|time|tmpnam|tolower|toupper|trace_psl_process|text_domain|unlock|unique|union|unset|va_arg|va_start|write)\b/,
          alias: "builtin-function"
        },
        "foreach-variable": {
          pattern: /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
          lookbehind: true,
          greedy: true
        },
        function: {
          pattern: /\b[_a-z]\w*\b(?=\s*\()/i
        },
        number: /\b(?:0x[0-9a-f]+|[0-9]+(?:\.[0-9]+)?)\b/i,
        operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
        punctuation: /[(){}\[\];,]/
      };
    }
  }
});

// node_modules/refractor/lang/qsharp.js
var require_qsharp = __commonJS({
  "node_modules/refractor/lang/qsharp.js"(exports, module) {
    "use strict";
    module.exports = qsharp;
    qsharp.displayName = "qsharp";
    qsharp.aliases = ["qs"];
    function qsharp(Prism) {
      ;
      (function(Prism2) {
        function replace(pattern, replacements) {
          return pattern.replace(/<<(\d+)>>/g, function(m, index) {
            return "(?:" + replacements[+index] + ")";
          });
        }
        function re(pattern, replacements, flags) {
          return RegExp(replace(pattern, replacements), flags || "");
        }
        function nested(pattern, depthLog2) {
          for (var i = 0; i < depthLog2; i++) {
            pattern = pattern.replace(/<<self>>/g, function() {
              return "(?:" + pattern + ")";
            });
          }
          return pattern.replace(/<<self>>/g, "[^\\s\\S]");
        }
        var keywordKinds = {
          // keywords which represent a return or variable type
          type: "Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero",
          // all other keywords
          other: "Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within"
        };
        function keywordsToPattern(words) {
          return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
        }
        var keywords = RegExp(
          keywordsToPattern(keywordKinds.type + " " + keywordKinds.other)
        );
        var identifier = /\b[A-Za-z_]\w*\b/.source;
        var qualifiedName = replace(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [identifier]);
        var typeInside = {
          keyword: keywords,
          punctuation: /[<>()?,.:[\]]/
        };
        var regularString = /"(?:\\.|[^\\"])*"/.source;
        Prism2.languages.qsharp = Prism2.languages.extend("clike", {
          comment: /\/\/.*/,
          string: [
            {
              pattern: re(/(^|[^$\\])<<0>>/.source, [regularString]),
              lookbehind: true,
              greedy: true
            }
          ],
          "class-name": [
            {
              // open Microsoft.Quantum.Canon;
              // open Microsoft.Quantum.Canon as CN;
              pattern: re(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [
                qualifiedName
              ]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // namespace Quantum.App1;
              pattern: re(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [qualifiedName]),
              lookbehind: true,
              inside: typeInside
            }
          ],
          keyword: keywords,
          number: /(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
          operator: /\band=|\bor=|\band\b|\bor\b|\bnot\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
          punctuation: /::|[{}[\];(),.:]/
        });
        Prism2.languages.insertBefore("qsharp", "number", {
          range: {
            pattern: /\.\./,
            alias: "operator"
          }
        });
        var interpolationExpr = nested(
          replace(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [regularString]),
          2
        );
        Prism2.languages.insertBefore("qsharp", "string", {
          "interpolation-string": {
            pattern: re(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [interpolationExpr]),
            greedy: true,
            inside: {
              interpolation: {
                pattern: re(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [
                  interpolationExpr
                ]),
                lookbehind: true,
                inside: {
                  punctuation: /^\{|\}$/,
                  expression: {
                    pattern: /[\s\S]+/,
                    alias: "language-qsharp",
                    inside: Prism2.languages.qsharp
                  }
                }
              },
              string: /[\s\S]+/
            }
          }
        });
      })(Prism);
      Prism.languages.qs = Prism.languages.qsharp;
    }
  }
});

// node_modules/refractor/lang/rego.js
var require_rego = __commonJS({
  "node_modules/refractor/lang/rego.js"(exports, module) {
    "use strict";
    module.exports = rego;
    rego.displayName = "rego";
    rego.aliases = [];
    function rego(Prism) {
      Prism.languages.rego = {
        comment: /#.*/,
        property: {
          pattern: /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
          lookbehind: true,
          greedy: true
        },
        string: {
          pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
          lookbehind: true,
          greedy: true
        },
        keyword: /\b(?:as|default|else|import|package|not|null|some|with|set(?=\s*\())\b/,
        boolean: /\b(?:true|false)\b/,
        function: {
          pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
          inside: {
            namespace: /\b\w+\b(?=\s*\.)/,
            punctuation: /\./
          }
        },
        number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
        punctuation: /[,;.\[\]{}()]/
      };
    }
  }
});

// node_modules/refractor/lang/squirrel.js
var require_squirrel = __commonJS({
  "node_modules/refractor/lang/squirrel.js"(exports, module) {
    "use strict";
    module.exports = squirrel;
    squirrel.displayName = "squirrel";
    squirrel.aliases = [];
    function squirrel(Prism) {
      Prism.languages.squirrel = Prism.languages.extend("clike", {
        comment: [
          Prism.languages.clike["comment"][0],
          {
            pattern: /(^|[^\\:])(?:\/\/|#).*/,
            lookbehind: true,
            greedy: true
          }
        ],
        string: [
          {
            pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
            lookbehind: true,
            greedy: true
          }
        ],
        "class-name": {
          pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
          lookbehind: true,
          inside: {
            punctuation: /\./
          }
        },
        keyword: /\b(?:base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield|__LINE__|__FILE__)\b/,
        number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
        operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
        punctuation: /[(){}\[\],;.]/
      });
      Prism.languages.insertBefore("squirrel", "operator", {
        "attribute-punctuation": {
          pattern: /<\/|\/>/,
          alias: "important"
        },
        lambda: {
          pattern: /@(?=\()/,
          alias: "operator"
        }
      });
    }
  }
});

// node_modules/refractor/lang/systemd.js
var require_systemd = __commonJS({
  "node_modules/refractor/lang/systemd.js"(exports, module) {
    "use strict";
    module.exports = systemd;
    systemd.displayName = "systemd";
    systemd.aliases = [];
    function systemd(Prism) {
      ;
      (function(Prism2) {
        var comment = {
          pattern: /^[;#].*/m,
          greedy: true
        };
        var quotesSource = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
        Prism2.languages.systemd = {
          comment,
          section: {
            pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
            greedy: true,
            inside: {
              punctuation: /^\[|\]$/,
              "section-name": {
                pattern: /[\s\S]+/,
                alias: "selector"
              }
            }
          },
          key: {
            pattern: /^[^\s=]+(?=[ \t]*=)/m,
            greedy: true,
            alias: "attr-name"
          },
          value: {
            // This pattern is quite complex because of two properties:
            //  1) Quotes (strings) must be preceded by a space. Since we can't use lookbehinds, we have to "resolve"
            //     the lookbehind. You will see this in the main loop where spaces are handled separately.
            //  2) Line continuations.
            //     After line continuations, empty lines and comments are ignored so we have to consume them.
            pattern: RegExp(
              /(=[ \t]*(?!\s))/.source + // the value either starts with quotes or not
              "(?:" + quotesSource + '|(?=[^"\r\n]))(?:' + (/[^\s\\]/.source + // handle spaces separately because of quotes
              '|[ 	]+(?:(?![ 	"])|' + quotesSource + ")|" + /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source) + ")*"
            ),
            lookbehind: true,
            greedy: true,
            alias: "attr-value",
            inside: {
              comment,
              quoted: {
                pattern: RegExp(/(^|\s)/.source + quotesSource),
                lookbehind: true,
                greedy: true
              },
              punctuation: /\\$/m,
              boolean: {
                pattern: /^(?:false|no|off|on|true|yes)$/,
                greedy: true
              }
            }
          },
          operator: /=/
        };
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/uri.js
var require_uri = __commonJS({
  "node_modules/refractor/lang/uri.js"(exports, module) {
    "use strict";
    module.exports = uri;
    uri.displayName = "uri";
    uri.aliases = ["url"];
    function uri(Prism) {
      Prism.languages.uri = {
        scheme: {
          pattern: /^[a-z][a-z0-9+.-]*:/im,
          greedy: true,
          inside: {
            "scheme-delimiter": /:$/
          }
        },
        fragment: {
          pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
          inside: {
            "fragment-delimiter": /^#/
          }
        },
        query: {
          pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
          inside: {
            "query-delimiter": {
              pattern: /^\?/,
              greedy: true
            },
            "pair-delimiter": /[&;]/,
            pair: {
              pattern: /^[^=][\s\S]*/,
              inside: {
                key: /^[^=]+/,
                value: {
                  pattern: /(^=)[\s\S]+/,
                  lookbehind: true
                }
              }
            }
          }
        },
        authority: {
          pattern: RegExp(
            /^\/\//.source + // [ userinfo "@" ]
            /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source + // host
            ("(?:" + // IP-literal
            /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source + "|" + // IPv4address or registered name
            /[\w\-.~!$&'()*+,;=%]*/.source + ")") + // [ ":" port ]
            /(?::\d*)?/.source,
            "m"
          ),
          inside: {
            "authority-delimiter": /^\/\//,
            "user-info-segment": {
              pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
              inside: {
                "user-info-delimiter": /@$/,
                "user-info": /^[\w\-.~!$&'()*+,;=%:]+/
              }
            },
            "port-segment": {
              pattern: /:\d*$/,
              inside: {
                "port-delimiter": /^:/,
                port: /^\d+/
              }
            },
            host: {
              pattern: /[\s\S]+/,
              inside: {
                "ip-literal": {
                  pattern: /^\[[\s\S]+\]$/,
                  inside: {
                    "ip-literal-delimiter": /^\[|\]$/,
                    "ipv-future": /^v[\s\S]+/,
                    "ipv6-address": /^[\s\S]+/
                  }
                },
                "ipv4-address": /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]{0,2})$/
              }
            }
          }
        },
        path: {
          pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
          inside: {
            "path-separator": /\//
          }
        }
      };
      Prism.languages.url = Prism.languages.uri;
    }
  }
});

// node_modules/refractor/lang/v.js
var require_v = __commonJS({
  "node_modules/refractor/lang/v.js"(exports, module) {
    "use strict";
    module.exports = v;
    v.displayName = "v";
    v.aliases = [];
    function v(Prism) {
      ;
      (function(Prism2) {
        var interpolationExpr = {
          pattern: /[\s\S]+/,
          inside: null
        };
        Prism2.languages.v = Prism2.languages.extend("clike", {
          string: [
            {
              pattern: /`(?:\\`|\\?[^`]{1,2})`/,
              // using {1,2} instead of `u` flag for compatibility
              alias: "rune"
            },
            {
              pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
              alias: "quoted-string",
              greedy: true,
              inside: {
                interpolation: {
                  pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
                  lookbehind: true,
                  inside: {
                    "interpolation-variable": {
                      pattern: /^\$\w[\s\S]*$/,
                      alias: "variable"
                    },
                    "interpolation-punctuation": {
                      pattern: /^\$\{|\}$/,
                      alias: "punctuation"
                    },
                    "interpolation-expression": interpolationExpr
                  }
                }
              }
            }
          ],
          "class-name": {
            pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
            lookbehind: true
          },
          keyword: /(?:\b(?:as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|__global|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:if|else|for)|#(?:include|flag))\b/,
          number: /\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
          operator: /~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
          builtin: /\b(?:any(?:_int|_float)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|nt|64|128)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
        });
        interpolationExpr.inside = Prism2.languages.v;
        Prism2.languages.insertBefore("v", "operator", {
          attribute: {
            pattern: /(^[\t ]*)\[(?:deprecated|unsafe_fn|typedef|live|inline|flag|ref_only|windows_stdcall|direct_array_access)\]/m,
            lookbehind: true,
            alias: "annotation",
            inside: {
              punctuation: /[\[\]]/,
              keyword: /\w+/
            }
          },
          generic: {
            pattern: /<\w+>(?=\s*[\)\{])/,
            inside: {
              punctuation: /[<>]/,
              "class-name": /\w+/
            }
          }
        });
        Prism2.languages.insertBefore("v", "function", {
          "generic-function": {
            // e.g. foo<T>( ...
            pattern: /\b\w+\s*<\w+>(?=\()/,
            inside: {
              function: /^\w+/,
              generic: {
                pattern: /<\w+>/,
                inside: Prism2.languages.v.generic.inside
              }
            }
          }
        });
      })(Prism);
    }
  }
});

// node_modules/refractor/lang/wolfram.js
var require_wolfram = __commonJS({
  "node_modules/refractor/lang/wolfram.js"(exports, module) {
    "use strict";
    module.exports = wolfram;
    wolfram.displayName = "wolfram";
    wolfram.aliases = ["mathematica", "wl", "nb"];
    function wolfram(Prism) {
      Prism.languages.wolfram = {
        // Allow one level of nesting - note: regex taken from applescipt
        comment: /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
        string: {
          pattern: /"(?:\\.|[^"\\\r\n])*"/,
          greedy: true
        },
        keyword: /\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
        context: {
          pattern: /\w+`+\w*/,
          alias: "class-name"
        },
        blank: {
          pattern: /\b\w+_\b/,
          alias: "regex"
        },
        "global-variable": {
          pattern: /\$\w+/,
          alias: "variable"
        },
        boolean: /\b(?:True|False)\b/,
        number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
        operator: /\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\^|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
        punctuation: /[\|{}[\];(),.:]/
      };
      Prism.languages.mathematica = Prism.languages.wolfram;
      Prism.languages.wl = Prism.languages.wolfram;
      Prism.languages.nb = Prism.languages.wolfram;
    }
  }
});

// node_modules/refractor/lang/wren.js
var require_wren = __commonJS({
  "node_modules/refractor/lang/wren.js"(exports, module) {
    "use strict";
    module.exports = wren;
    wren.displayName = "wren";
    wren.aliases = [];
    function wren(Prism) {
      Prism.languages.wren = {
        // Multiline comments in Wren can have nested multiline comments
        // Comments: // and /* */
        comment: [
          {
            // support 3 levels of nesting
            // regex: \/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\/
            pattern: /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        // Triple quoted strings are multiline but cannot have interpolation (raw strings)
        // Based on prism-python.js
        "triple-quoted-string": {
          pattern: /"""[\s\S]*?"""/,
          greedy: true,
          alias: "string"
        },
        // see below
        "string-literal": null,
        // #!/usr/bin/env wren on the first line
        hashbang: {
          pattern: /^#!\/.+/,
          greedy: true,
          alias: "comment"
        },
        // Attributes are special keywords to add meta data to classes
        attribute: {
          // #! attributes are stored in class properties
          // #!myvar = true
          // #attributes are not stored and dismissed at compilation
          pattern: /#!?[ \t\u3000]*\w+/,
          alias: "keyword"
        },
        "class-name": [
          {
            // class definition
            // class Meta {}
            pattern: /(\bclass\s+)\w+/,
            lookbehind: true
          },
          // A class must always start with an uppercase.
          // File.read
          /\b[A-Z][a-z\d_]*\b/
        ],
        // A constant can be a variable, class, property or method. Just named in all uppercase letters
        constant: /\b[A-Z][A-Z\d_]*\b/,
        null: {
          pattern: /\bnull\b/,
          alias: "keyword"
        },
        keyword: /\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
        boolean: /\b(?:true|false)\b/,
        number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
        // Functions can be Class.method()
        function: /\b[a-z_]\w*(?=\s*[({])/i,
        operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
        punctuation: /[\[\](){}.,;]/
      };
      Prism.languages.wren["string-literal"] = {
        // A single quote string is multiline and can have interpolation (similar to JS backticks ``)
        pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
        lookbehind: true,
        greedy: true,
        inside: {
          interpolation: {
            // "%(interpolation)"
            pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
            lookbehind: true,
            inside: {
              expression: {
                pattern: /^(%\()[\s\S]+(?=\)$)/,
                lookbehind: true,
                inside: Prism.languages.wren
              },
              "interpolation-punctuation": {
                pattern: /^%\(|\)$/,
                alias: "punctuation"
              }
            }
          },
          string: /[\s\S]+/
        }
      };
    }
  }
});

// node_modules/refractor/index.js
var require_refractor = __commonJS({
  "node_modules/refractor/index.js"(exports, module) {
    var refractor = require_core();
    module.exports = refractor;
    refractor.register(require_abap());
    refractor.register(require_abnf());
    refractor.register(require_actionscript());
    refractor.register(require_ada());
    refractor.register(require_agda());
    refractor.register(require_al());
    refractor.register(require_antlr4());
    refractor.register(require_apacheconf());
    refractor.register(require_apex());
    refractor.register(require_apl());
    refractor.register(require_applescript());
    refractor.register(require_aql());
    refractor.register(require_arduino());
    refractor.register(require_arff());
    refractor.register(require_asciidoc());
    refractor.register(require_asm6502());
    refractor.register(require_aspnet());
    refractor.register(require_autohotkey());
    refractor.register(require_autoit());
    refractor.register(require_avisynth());
    refractor.register(require_avro_idl());
    refractor.register(require_bash());
    refractor.register(require_basic());
    refractor.register(require_batch());
    refractor.register(require_bbcode());
    refractor.register(require_bicep());
    refractor.register(require_birb());
    refractor.register(require_bison());
    refractor.register(require_bnf());
    refractor.register(require_brainfuck());
    refractor.register(require_brightscript());
    refractor.register(require_bro());
    refractor.register(require_bsl());
    refractor.register(require_c());
    refractor.register(require_cfscript());
    refractor.register(require_chaiscript());
    refractor.register(require_cil());
    refractor.register(require_clojure());
    refractor.register(require_cmake());
    refractor.register(require_cobol());
    refractor.register(require_coffeescript());
    refractor.register(require_concurnas());
    refractor.register(require_coq());
    refractor.register(require_cpp());
    refractor.register(require_crystal());
    refractor.register(require_csharp());
    refractor.register(require_cshtml());
    refractor.register(require_csp());
    refractor.register(require_css_extras());
    refractor.register(require_csv());
    refractor.register(require_cypher());
    refractor.register(require_d());
    refractor.register(require_dart());
    refractor.register(require_dataweave());
    refractor.register(require_dax());
    refractor.register(require_dhall());
    refractor.register(require_diff());
    refractor.register(require_django());
    refractor.register(require_dns_zone_file());
    refractor.register(require_docker());
    refractor.register(require_dot());
    refractor.register(require_ebnf());
    refractor.register(require_editorconfig());
    refractor.register(require_eiffel());
    refractor.register(require_ejs());
    refractor.register(require_elixir());
    refractor.register(require_elm());
    refractor.register(require_erb());
    refractor.register(require_erlang());
    refractor.register(require_etlua());
    refractor.register(require_excel_formula());
    refractor.register(require_factor());
    refractor.register(require_false());
    refractor.register(require_firestore_security_rules());
    refractor.register(require_flow());
    refractor.register(require_fortran());
    refractor.register(require_fsharp());
    refractor.register(require_ftl());
    refractor.register(require_gap());
    refractor.register(require_gcode());
    refractor.register(require_gdscript());
    refractor.register(require_gedcom());
    refractor.register(require_gherkin());
    refractor.register(require_git());
    refractor.register(require_glsl());
    refractor.register(require_gml());
    refractor.register(require_gn());
    refractor.register(require_go());
    refractor.register(require_graphql());
    refractor.register(require_groovy());
    refractor.register(require_haml());
    refractor.register(require_handlebars());
    refractor.register(require_haskell());
    refractor.register(require_haxe());
    refractor.register(require_hcl());
    refractor.register(require_hlsl());
    refractor.register(require_hoon());
    refractor.register(require_hpkp());
    refractor.register(require_hsts());
    refractor.register(require_http());
    refractor.register(require_ichigojam());
    refractor.register(require_icon());
    refractor.register(require_icu_message_format());
    refractor.register(require_idris());
    refractor.register(require_iecst());
    refractor.register(require_ignore());
    refractor.register(require_inform7());
    refractor.register(require_ini());
    refractor.register(require_io());
    refractor.register(require_j());
    refractor.register(require_java());
    refractor.register(require_javadoc());
    refractor.register(require_javadoclike());
    refractor.register(require_javastacktrace());
    refractor.register(require_jexl());
    refractor.register(require_jolie());
    refractor.register(require_jq());
    refractor.register(require_js_extras());
    refractor.register(require_js_templates());
    refractor.register(require_jsdoc());
    refractor.register(require_json());
    refractor.register(require_json5());
    refractor.register(require_jsonp());
    refractor.register(require_jsstacktrace());
    refractor.register(require_jsx());
    refractor.register(require_julia());
    refractor.register(require_keyman());
    refractor.register(require_kotlin());
    refractor.register(require_kumir());
    refractor.register(require_kusto());
    refractor.register(require_latex());
    refractor.register(require_latte());
    refractor.register(require_less());
    refractor.register(require_lilypond());
    refractor.register(require_liquid());
    refractor.register(require_lisp());
    refractor.register(require_livescript());
    refractor.register(require_llvm());
    refractor.register(require_log());
    refractor.register(require_lolcode());
    refractor.register(require_lua());
    refractor.register(require_magma());
    refractor.register(require_makefile());
    refractor.register(require_markdown());
    refractor.register(require_markup_templating());
    refractor.register(require_matlab());
    refractor.register(require_maxscript());
    refractor.register(require_mel());
    refractor.register(require_mermaid());
    refractor.register(require_mizar());
    refractor.register(require_mongodb());
    refractor.register(require_monkey());
    refractor.register(require_moonscript());
    refractor.register(require_n1ql());
    refractor.register(require_n4js());
    refractor.register(require_nand2tetris_hdl());
    refractor.register(require_naniscript());
    refractor.register(require_nasm());
    refractor.register(require_neon());
    refractor.register(require_nevod());
    refractor.register(require_nginx());
    refractor.register(require_nim());
    refractor.register(require_nix());
    refractor.register(require_nsis());
    refractor.register(require_objectivec());
    refractor.register(require_ocaml());
    refractor.register(require_opencl());
    refractor.register(require_openqasm());
    refractor.register(require_oz());
    refractor.register(require_parigp());
    refractor.register(require_parser());
    refractor.register(require_pascal());
    refractor.register(require_pascaligo());
    refractor.register(require_pcaxis());
    refractor.register(require_peoplecode());
    refractor.register(require_perl());
    refractor.register(require_php_extras());
    refractor.register(require_php());
    refractor.register(require_phpdoc());
    refractor.register(require_plsql());
    refractor.register(require_powerquery());
    refractor.register(require_powershell());
    refractor.register(require_processing());
    refractor.register(require_prolog());
    refractor.register(require_promql());
    refractor.register(require_properties());
    refractor.register(require_protobuf());
    refractor.register(require_psl());
    refractor.register(require_pug());
    refractor.register(require_puppet());
    refractor.register(require_pure());
    refractor.register(require_purebasic());
    refractor.register(require_purescript());
    refractor.register(require_python());
    refractor.register(require_q());
    refractor.register(require_qml());
    refractor.register(require_qore());
    refractor.register(require_qsharp());
    refractor.register(require_r());
    refractor.register(require_racket());
    refractor.register(require_reason());
    refractor.register(require_regex());
    refractor.register(require_rego());
    refractor.register(require_renpy());
    refractor.register(require_rest());
    refractor.register(require_rip());
    refractor.register(require_roboconf());
    refractor.register(require_robotframework());
    refractor.register(require_ruby());
    refractor.register(require_rust());
    refractor.register(require_sas());
    refractor.register(require_sass());
    refractor.register(require_scala());
    refractor.register(require_scheme());
    refractor.register(require_scss());
    refractor.register(require_shell_session());
    refractor.register(require_smali());
    refractor.register(require_smalltalk());
    refractor.register(require_smarty());
    refractor.register(require_sml());
    refractor.register(require_solidity());
    refractor.register(require_solution_file());
    refractor.register(require_soy());
    refractor.register(require_sparql());
    refractor.register(require_splunk_spl());
    refractor.register(require_sqf());
    refractor.register(require_sql());
    refractor.register(require_squirrel());
    refractor.register(require_stan());
    refractor.register(require_stylus());
    refractor.register(require_swift());
    refractor.register(require_systemd());
    refractor.register(require_t4_cs());
    refractor.register(require_t4_templating());
    refractor.register(require_t4_vb());
    refractor.register(require_tap());
    refractor.register(require_tcl());
    refractor.register(require_textile());
    refractor.register(require_toml());
    refractor.register(require_tsx());
    refractor.register(require_tt2());
    refractor.register(require_turtle());
    refractor.register(require_twig());
    refractor.register(require_typescript());
    refractor.register(require_typoscript());
    refractor.register(require_unrealscript());
    refractor.register(require_uri());
    refractor.register(require_v());
    refractor.register(require_vala());
    refractor.register(require_vbnet());
    refractor.register(require_velocity());
    refractor.register(require_verilog());
    refractor.register(require_vhdl());
    refractor.register(require_vim());
    refractor.register(require_visual_basic());
    refractor.register(require_warpscript());
    refractor.register(require_wasm());
    refractor.register(require_wiki());
    refractor.register(require_wolfram());
    refractor.register(require_wren());
    refractor.register(require_xeora());
    refractor.register(require_xml_doc());
    refractor.register(require_xojo());
    refractor.register(require_xquery());
    refractor.register(require_yaml());
    refractor.register(require_yang());
    refractor.register(require_zig());
  }
});

export {
  require_refractor
};
//# sourceMappingURL=/build/_shared/chunk-NU3CQXHL.js.map
