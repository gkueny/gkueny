---
title: Prot√©ger son application
author: Gkueny
date: 2017-05-13T19:00:00
keywords: react, firebase, security
excerpt: "Lorsque l‚Äôon code une application `React`, on est vite amen√© √† prot√©ger l‚Äôacc√®s √† une partie de celle-ci. Je vais vous montrer ici ma technique pr√©f√©r√©e afin de `filtrer l'acc√®s` √† certains composants."
---

> **Attention, cet article n'est pas √† jour.**

Lorsque l‚Äôon code une application `React`, on est vite amen√© √† prot√©ger l‚Äôacc√®s √† une partie de celle-ci. Je vais vous montrer ici ma technique pr√©f√©r√©e afin de `filtrer l'acc√®s` √† certains composants.

> Cette technique est applicable autant pour React que pour React-Native, mais pour les besoins de l‚Äôarticle, je prendrai seulement exemple sur une application React.

## Principe g√©n√©ral

Afin d‚Äôinterdire l‚Äôacc√®s √† certain composant si l‚Äôutilisateur n‚Äôest pas authentifi√© ou n‚Äôa pas les bons droits, nous allons englober ceux-ci dans un `super-composant`. Il n‚Äôaura qu‚Äôun seul but :

- v√©rifier un certain nombre de conditions et agir en cons√©quence.

Si les conditions requises sont r√©unies, le composant affichera ce qui est demand√©, sinon il redirigera l‚Äôutilisateur.

## Prot√©ger son Application

### Application de base

Prenons une simple application web avec trois routes diff√©rentes

- Accueil
- Login
- Admin

et avec le code ci-dessous (extrait) :

```jsx
import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter as Router, Route } from "react-router-dom";

import AppComponent from "./components/app.component";
import HomeComponent from "./components/home.component";
import AdminComponent from "./components/admin.component";
import LoginComponent from "./components/login.component";

import * as firebase from "firebase";
import { config } from "./vars/firebase.config";
import "./assets/css/index.css";

firebase.initializeApp(config);

ReactDOM.render(
  <Router>
    <AppComponent>
      <Route exact path="/" component={HomeComponent} />
      <Route path="/admin" component={AdminComponent} />
      <Route path="/login" component={LoginComponent} />
    </AppComponent>
  </Router>,
  document.getElementById("root")
);
```

Pour voir l‚Äôapplication que j‚Äôai cod√©e pour cet article, c‚Äôest par ici : [https://github.com/gkueny/protect-route-react](https://github.com/gkueny/protect-route-react)
J‚Äôutilise [Firebase](http://frenchreact.fr/utiliser-firebase-avec-react/) et [React Router v4](https://reacttraining.com/react-router/web/guides/quick-start).

> `/!\` Pour l‚Äôinstant, notre composant AdminComponent est en libre acc√®s `/!\`.

Ce que l‚Äôon cherche donc √† faire, c‚Äôest de v√©rifier le token de l‚Äôutilisateur (qu‚Äôil en est un et que le serveur nous confirme son authenticit√©) et d‚Äôagir en cons√©quence.

### Notre super-composant

Une solution rapide, serait d‚Äôeffectuer nos v√©rifications directement dans le composant `AdminComponent`. Cela marcherai, mais on serait amen√© √† recopier le code pour chaque composant √† prot√©ger. Pas tr√®s efficace comme m√©thode et chronophage üôÅ .

Au lieu de cela, nous allons construire un `composant` qui englobera les composants √† prot√©ger et fera ces v√©rifications pour nous :

```jsx
import React, { Component } from "react";
import PropTypes from "prop-types";

import { Route, Redirect } from "react-router-dom";
import { checkUserStatus } from "../services/user.service";

class ProtectedRoute extends Component {
  constructor() {
    super();
    this.state = {
      isLogIn: null,
    };
  }

  componentDidMount() {
    //On check le statut de l'utilisateur aupr√®s du serveur, et on agit en cons√©quance
    checkUserStatus().then(this.updateUserStatus);
  }

  //Sera appel√© lorsque l'on changera de route
  componentWillReceiveProps(nextProps) {
    this.state = {
      isLogIn: null,
    };
    //On fait √©galement cette v√©rification lors d'un changement
    checkUserStatus().then(this.updateUserStatus);
  }

  updateUserStatus = (isLogIn) => {
    if (this.state.isLogIn !== isLogIn) {
      this.setState({
        isLogIn,
      });
    }
  };

  render() {
    const { component: Component, ...rest } = this.props;

    return (
      <Route
        {...rest}
        render={(props) => {
          if (this.state.isLogIn) {
            return <Component {...props} />;
          } else if (this.state.isLogIn !== null) {
            return <Redirect to={"login"} />;
          } else {
            return null;
          }
        }}
      />
    );
  }
}

ProtectedRoute.propTypes = {
  component: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  location: PropTypes.object,
};

export default ProtectedRoute;
```

Ici, √† chaque fois qu‚Äôune des routes g√©r√© par `ProtectedRoute` est appel√©e, la fonction `componentWillReceiveProps()` sera ex√©cut√©e, car le composant `Router` d√©finit dans `index.js` ¬´ re-rend ¬ª notre composant lors d‚Äôun changement de route.

On profite donc de cette fonction pour v√©rifier les droits de l‚Äôutilisateur et afficher ou non la route demand√©e.

## Int√©gration du super-composant

Pour int√©grer notre `super-composant`, il nous suffit de modifier la fonction `render()` de notre fichier `index.js` :

```jsx
<Router>
  <AppComponent>
    <Route exact path="/" component={HomeComponent} />
    <Route path="/login" component={LoginComponent} />
    <ProtectedRoute path="/admin" component={AdminComponent} />
  </AppComponent>
</Router>
```

    Et c'est tout !

On a donc juste eu besoin de d√©finir une surcouche du composant `Route` pour prot√©ger certaines d‚Äôentre elle. Avec ce code la lecture du code est assez intuitif et nous n‚Äôaurons pas besoin de faire de copier-coller pour chaque composant priv√©.
